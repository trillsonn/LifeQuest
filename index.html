<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover, interactive-widget=resizes-content">
    <title>MeMaster - AI Task Planner</title>
    
    <!-- PWA Meta Tags -->
    <meta name="description" content="AI-powered task planning and scheduling app to help you organize your perfect day">
    <meta name="theme-color" content="#667eea">
    <meta name="background-color" content="#15202B">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="MeMaster">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="application-name" content="MeMaster">
    
    <!-- PWA Icons -->
    <link rel="apple-touch-icon" href="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTkyIiBoZWlnaHQ9IjE5MiIgdmlld0JveD0iMCAwIDE5MiAxOTIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSIxOTIiIGhlaWdodD0iMTkyIiByeD0iMjQiIGZpbGw9IiM2NjdlZWEiLz4KPHN2ZyB4PSI0OCIgeT0iNDgiIHdpZHRoPSI5NiIgaGVpZ2h0PSI5NiIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJ3aGl0ZSI+CjxwYXRoIGQ9Ik05IDEyTDExIDEyTDE1IDhNMjEgMTJDMjEgMTYuOTcwNiAxNi45NzA2IDIxIDEyIDIxQzcuMDI5NDQgMjEgMyAxNi45NzA2IDMgMTJDMyA3LjAyOTQ0IDcuMDI5NDQgMyAxMiAzqte16Ljk3MDYgMyAyMSA3LjAyOTQ0IDIxIDEyWiIgc3Ryb2tlPSJ3aGl0ZSIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiLz4KPC9zdmc+Cjwvc3ZnPgo=">
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTkyIiBoZWlnaHQ9IjE5MiIgdmlld0JveD0iMCAwIDE5MiAxOTIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSIxOTIiIGhlaWdodD0iMTkyIiByeD0iMjQiIGZpbGw9IiM2NjdlZWEiLz4KPHN2ZyB4PSI0OCIgeT0iNDgiIHdpZHRoPSI5NiIgaGVpZ2h0PSI5NiIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJ3aGl0ZSI+CjxwYXRoIGQ9Ik05IDEyTDExIDEyTDE1IDhNMjEgMTJDMjEgMTYuOTcwNiAxNi45NzA2IDIxIDEyIDIxQzcuMDI5NDQgMjEgMyAxNi45NzA2IDMgMTJDMyA3LjAyOTQ0IDcuMDI5NDQgMyAxMiAzqte16Ljk3MDYgMyAyMSA3LjAyOTQ0IDIxIDEyWiIgc3Ryb2tlPSJ3aGl0ZSIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiLz4KPC9zdmc+Cjwvc3ZnPgo=">
    
    <!-- PWA Manifest -->
    <link rel="manifest" href="./manifest.json">
    
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        /* Ensure all input text is visible - Mobile Safari Fix */
        input[type="text"], 
        input[type="email"], 
        input[type="password"], 
        textarea, 
        select {
            color: #ffffff !important;
            -webkit-text-fill-color: #ffffff !important;
            -webkit-opacity: 1 !important;
            -webkit-appearance: none !important;
            appearance: none !important;
            background-color: transparent !important;
            caret-color: #ffffff !important;
        }

        input[type="text"]:focus, 
        input[type="email"]:focus, 
        input[type="password"]:focus, 
        textarea:focus, 
        select:focus {
            color: #ffffff !important;
            -webkit-text-fill-color: #ffffff !important;
            -webkit-opacity: 1 !important;
            background-color: transparent !important;
            caret-color: #ffffff !important;
        }

        /* iOS Safari specific fixes */
        input, textarea, select {
            -webkit-user-select: text !important;
            -webkit-touch-callout: default !important;
            -webkit-tap-highlight-color: rgba(255, 255, 255, 0.1) !important;
        }

        /* Ultimate fallback for mobile text visibility */
        .mobile-container input,
        .mobile-container textarea,
        .mobile-container select {
            color: white !important;
            -webkit-text-fill-color: white !important;
            text-shadow: 0 0 1px rgba(255, 255, 255, 0.8) !important;
        }

        /* Force white text on all form elements */
        input:not([type="submit"]):not([type="button"]):not([type="reset"]),
        textarea,
        select {
            color: #ffffff !important;
            -webkit-text-fill-color: #ffffff !important;
            background: rgba(255, 255, 255, 0.1) !important;
        }

        /* Emergency visibility fix for iOS */
        @supports (-webkit-appearance: none) {
            input[type="text"],
            textarea {
                color: white !important;
                -webkit-text-fill-color: white !important;
                background-color: rgba(0, 0, 0, 0.3) !important;
                border: 2px solid rgba(255, 255, 255, 0.3) !important;
            }
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #15202B;
            color: #ffffff;
            min-height: 100vh;
            overflow-x: hidden;
            user-select: none;
            width: 100vw;
            max-width: 100%;
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            overflow-x: hidden;
            width: 100%;
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        /* Prevent any element from causing horizontal scroll on mobile */
        * {
            box-sizing: border-box;
        }

        /* iOS Safari viewport fix */
        @supports (-webkit-touch-callout: none) {
            .chat-input-container {
                bottom: env(safe-area-inset-bottom, 0px);
                padding-bottom: calc(15px + env(safe-area-inset-bottom, 0px));
            }
            
            .ai-chat-modal {
                height: 100vh;
                height: -webkit-fill-available;
            }
            
            .chat-messages {
                max-height: calc(100vh - 140px);
                max-height: calc(-webkit-fill-available - 140px);
            }
        }

        /* Additional fix for iOS portrait mode */
        @media screen and (max-width: 375px) and (orientation: portrait) {
            .chat-input-container {
                bottom: 0;
                position: fixed !important;
                z-index: 200 !important;
            }
            
            .detected-tasks-container {
                margin: 15px 0 !important;
                padding: 12px !important;
            }
            
            .chat-messages {
                height: calc(100vh - 130px);
                padding-bottom: 130px;
            }
        }

        .mobile-container {
            width: 100vw;
            max-width: 100%;
            margin: 0;
            min-height: 100vh;
            background: linear-gradient(135deg, #1e2732 0%, #15202B 100%);
            position: relative;
            box-sizing: border-box;
            padding: 0;
        }

        /* Responsive adjustments for different screen sizes */
        @media screen and (max-width: 375px) {
            /* iPhone 12 Mini, iPhone SE */
            .mobile-container {
                padding: 0 5px;
            }
        }

        @media screen and (min-width: 376px) and (max-width: 414px) {
            /* iPhone 12, iPhone 12 Pro, iPhone 13 */
            .mobile-container {
                padding: 0 10px;
            }
        }

        @media screen and (min-width: 415px) {
            /* iPhone 12 Pro Max, iPhone 13 Pro Max */
            .mobile-container {
                max-width: 428px;
                margin: 0 auto;
                padding: 0 15px;
            }
        }

        /* Welcome Screen */
        .welcome-screen {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 40px 20px;
            text-align: center;
        }

        .app-logo {
            width: 120px;
            height: 120px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 25px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 40px;
            box-shadow: 0 10px 30px rgba(102, 126, 234, 0.3);
        }

        .app-logo i {
            font-size: 50px;
            color: white;
        }

        .welcome-screen h1 {
            font-size: 48px;
            font-weight: 300;
            margin-bottom: 20px;
            color: #ffffff;
        }

        .welcome-screen p {
            font-size: 18px;
            color: #999;
            margin-bottom: 60px;
            line-height: 1.5;
        }

        .welcome-actions {
            display: flex;
            flex-direction: column;
            gap: 15px;
            width: 100%;
            max-width: 280px;
        }

        .welcome-btn {
            padding: 18px 24px;
            border-radius: 12px;
            border: none;
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 100%;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: #667eea;
            border: 1px solid rgba(102, 126, 234, 0.3);
        }

        .welcome-btn:active {
            transform: scale(0.98);
        }

        /* Main App Screen */
        .main-screen {
            display: none;
            min-height: 100vh;
            padding: 60px 15px 120px;
            box-sizing: border-box;
            width: 100%;
        }

        /* Responsive padding for iPhone 12 and smaller */
        @media screen and (max-width: 375px) {
            .main-screen {
                padding: 55px 10px 120px;
            }
        }

        .main-screen.active {
            display: block;
        }

        .status-bar {
            position: fixed;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 100%;
            max-width: 390px;
            height: 44px;
            background: rgba(21, 32, 43, 0.95);
            backdrop-filter: blur(20px);
            z-index: 100;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 0 20px;
            font-size: 14px;
            font-weight: 600;
            position: relative;
        }
        
        .sync-status {
            position: absolute;
            right: 15px;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 12px;
            opacity: 0.8;
        }
        
        .sync-status.online {
            color: #51cf66;
        }
        
        .sync-status.offline {
            color: #ff6b6b;
        }
        
        .sync-status.syncing {
            color: #667eea;
        }
        
        .sync-icon {
            font-size: 10px;
        }
        
        .sync-icon.spinning {
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .question-header {
            text-align: center;
            margin-bottom: 40px;
        }

        .question-header h2 {
            font-size: 28px;
            font-weight: 300;
            line-height: 1.3;
            color: #ffffff;
            margin-bottom: 10px;
        }

        .add-task-container {
            margin-bottom: 20px;
        }

        .add-task-btn {
            width: 100%;
            padding: 16px 20px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            color: #999;
            font-size: 16px;
            text-align: left;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .add-task-btn:active {
            background: rgba(255, 255, 255, 0.15);
        }

        /* Chat Input Bar */
        .chat-input-bar {
            position: fixed;
            bottom: 120px; /* Moved much higher up */
            left: 0;
            right: 0;
            width: 100vw;
            padding: 8px 15px; /* Reduced padding */
            background: rgba(21, 32, 43, 0.98);
            backdrop-filter: blur(20px);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            gap: 12px;
            align-items: center;
            z-index: 60;
            box-sizing: border-box;
        }

        /* Responsive chat input bar */
        @media screen and (max-width: 375px) {
            .chat-input-bar {
                padding: 8px 12px;
                gap: 8px;
            }
        }

        @media screen and (min-width: 415px) {
            .chat-input-bar {
                left: 50%;
                transform: translateX(-50%);
                max-width: 428px;
                width: 100%;
            }
        }

        .bottom-chat-input {
            flex: 1;
            padding: 12px 18px;
            background: rgba(255, 255, 255, 0.1) !important;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 25px;
            color: #ffffff !important;
            font-size: 15px;
            outline: none;
            transition: all 0.3s ease;
            -webkit-text-fill-color: #ffffff !important;
            -webkit-opacity: 1 !important;
            -webkit-appearance: none !important;
            appearance: none !important;
            caret-color: #ffffff !important;
        }

        .bottom-chat-input:focus {
            border-color: #667eea;
            background: rgba(255, 255, 255, 0.15) !important;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
            color: #ffffff !important;
            -webkit-text-fill-color: #ffffff !important;
            -webkit-appearance: none !important;
            appearance: none !important;
            caret-color: #ffffff !important;
        }

        .bottom-chat-input::placeholder {
            color: #666 !important;
        }

        .voice-input-btn {
            width: 44px;
            height: 44px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            color: white;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }

        .voice-input-btn:active {
            transform: scale(0.95);
            box-shadow: 0 2px 10px rgba(102, 126, 234, 0.6);
        }

        .voice-input-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }

        .voice-input-btn.recording {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a24 100%);
            animation: voicePulse 1.5s infinite;
        }

        @keyframes voicePulse {
            0% { transform: scale(1); box-shadow: 0 4px 15px rgba(255, 107, 107, 0.3); }
            50% { transform: scale(1.05); box-shadow: 0 6px 20px rgba(255, 107, 107, 0.5); }
            100% { transform: scale(1); box-shadow: 0 4px 15px rgba(255, 107, 107, 0.3); }
        }

        /* Ripple effect for touch feedback */
        .voice-input-btn::before {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            transform: scale(0);
            transition: transform 0.3s ease;
        }

        .voice-input-btn:active::before {
            transform: scale(1.2);
            transition: transform 0.1s ease;
        }

        .ai-button {
            position: absolute;
            right: 15px;
            top: 50%;
            transform: translateY(-50%);
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            padding: 8px;
            border-radius: 8px;
            color: white;
            cursor: pointer;
        }

        /* Todo List */
        .todo-list {
            list-style: none;
        }

        .todo-item {
            margin-bottom: 12px;
            border-radius: 12px;
            position: relative;
            overflow: hidden;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
        }

        .todo-item-wrapper {
            display: flex;
            align-items: center;
            justify-content: space-between;
            position: relative;
            transition: transform 0.3s ease;
            width: 100%;
        }

        .todo-item-content {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 18px 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            flex: 1;
            transition: all 0.3s ease;
        }

        .todo-item-content:active {
            transform: scale(0.98);
            background: rgba(255, 255, 255, 0.08);
        }

        .todo-item.swiped .todo-item-wrapper {
            transform: translateX(-80px);
        }

        .todo-delete-area {
            position: absolute;
            right: 0;
            top: 0;
            bottom: 0;
            width: 80px;
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a24 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transform: translateX(20px);
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .todo-item.swiped .todo-delete-area {
            opacity: 1;
            transform: translateX(0);
            animation: deleteReveal 0.3s ease;
        }

        @keyframes deleteReveal {
            0% { 
                opacity: 0; 
                transform: translateX(20px) scale(0.8); 
            }
            50% { 
                transform: translateX(-5px) scale(1.1); 
            }
            100% { 
                opacity: 1; 
                transform: translateX(0) scale(1); 
            }
        }

        .todo-delete-icon {
            color: white;
            font-size: 20px;
            transition: transform 0.2s ease;
        }

        .todo-delete-area:active .todo-delete-icon {
            transform: scale(1.2);
        }

        /* Visual feedback during swipe */
        .todo-item.swiping .todo-item-content {
            background: rgba(255, 255, 255, 0.08);
        }

        .todo-number {
            font-size: 18px;
            font-weight: 600;
            color: #667eea;
            min-width: 25px;
        }

        .todo-text {
            flex: 1;
            font-size: 17px;
            color: #ffffff;
            line-height: 1.4;
        }

        .todo-item.completed .todo-text {
            color: #666;
            text-decoration: line-through;
        }

        .todo-item.completed .todo-item-content {
            opacity: 0.7;
        }
        
        /* Add subtle border to separate completed tasks */
        .todo-item.completed {
            border-color: rgba(255, 255, 255, 0.05);
            background: rgba(255, 255, 255, 0.02);
        }

        .todo-checkbox {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            border: 2px solid #666;
            background: transparent;
            cursor: pointer;
            position: relative;
            transition: all 0.3s ease;
            margin-right: 20px;
            z-index: 10;
            flex-shrink: 0;
        }

        .todo-checkbox.checked {
            background: #4CAF50;
            border-color: #4CAF50;
        }

        .todo-checkbox.checked::after {
            content: '✓';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 14px;
            font-weight: bold;
        }

        /* Bottom Navigation */
        .bottom-nav {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            width: 100vw;
            height: 85px;
            background: rgba(21, 32, 43, 0.95);
            backdrop-filter: blur(20px);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            justify-content: space-around;
            align-items: center;
            padding-bottom: 20px;
            z-index: 40;
            box-sizing: border-box;
        }

        /* Responsive bottom navigation */
        @media screen and (max-width: 375px) and (orientation: portrait) {
            .bottom-nav {
                padding-bottom: max(20px, env(safe-area-inset-bottom));
                height: auto;
                min-height: 85px;
            }
        }

        @media screen and (min-width: 415px) {
            .bottom-nav {
                left: 50%;
                transform: translateX(-50%);
                max-width: 428px;
                width: 100%;
            }
        }

        .nav-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            cursor: pointer;
            transition: all 0.3s ease;
            padding: 8px 16px;
            border-radius: 12px;
        }

        .nav-item.active {
            background: rgba(102, 126, 234, 0.2);
        }

        .nav-item i {
            font-size: 22px;
            color: #666;
            transition: color 0.3s ease;
        }

        .nav-item.active i {
            color: #667eea;
        }

        .nav-item span {
            font-size: 11px;
            color: #666;
            font-weight: 500;
        }

        .nav-item.active span {
            color: #667eea;
        }

        /* AI Suggestions Modal */
        .ai-suggestions-modal {
            position: fixed;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 100%;
            max-width: 390px;
            height: 100vh;
            background: #1a1a1a;
            z-index: 200;
            display: none;
            flex-direction: column;
        }

        .ai-suggestions-modal.active {
            display: flex;
        }

        .modal-header {
            padding: 60px 20px 20px;
            text-align: center;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .modal-header h3 {
            font-size: 24px;
            font-weight: 300;
            color: #ffffff;
            margin-bottom: 10px;
        }

        .modal-header p {
            color: #999;
            font-size: 16px;
        }

        .suggestions-list {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
        }

        .suggestion-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 18px 20px;
            margin-bottom: 12px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .suggestion-text {
            color: #ffffff;
            font-size: 16px;
            flex: 1;
        }

        .add-suggestion-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 14px;
            cursor: pointer;
        }

        .close-modal {
            position: absolute;
            top: 60px;
            right: 20px;
            background: none;
            border: none;
            color: #667eea;
            font-size: 18px;
            cursor: pointer;
        }

        /* Input Modal */
        .input-modal {
            position: fixed;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 100%;
            max-width: 390px;
            height: 100vh;
            background: #15202B;
            z-index: 200;
            display: none;
            flex-direction: column;
        }

        .input-modal.active {
            display: flex;
        }

        .input-header {
            padding: 60px 20px 20px;
            text-align: center;
        }

        .input-header h3 {
            font-size: 24px;
            font-weight: 300;
            color: #ffffff;
            margin-bottom: 30px;
        }

        .task-input {
            width: 100%;
            padding: 18px 20px;
            background: rgba(255, 255, 255, 0.1) !important;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            color: #ffffff !important;
            font-size: 16px;
            outline: none;
            margin-bottom: 20px;
            -webkit-text-fill-color: #ffffff !important;
            -webkit-opacity: 1 !important;
            -webkit-appearance: none !important;
            appearance: none !important;
            caret-color: #ffffff !important;
        }

        .task-input:focus {
            background: rgba(255, 255, 255, 0.15) !important;
            color: #ffffff !important;
            -webkit-text-fill-color: #ffffff !important;
            -webkit-appearance: none !important;
            appearance: none !important;
            caret-color: #ffffff !important;
        }

        .task-input::placeholder {
            color: #666 !important;
        }

        .input-actions {
            display: flex;
            gap: 15px;
            padding: 20px;
            position: absolute;
            bottom: 100px;
            left: 0;
            right: 0;
        }

        .input-btn {
            flex: 1;
            padding: 16px;
            border-radius: 12px;
            border: none;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
        }

        .btn-cancel {
            background: rgba(255, 255, 255, 0.1);
            color: #999;
        }

        .btn-add {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        /* Calendar View */
        .calendar-view {
            display: none;
            padding: 60px 15px 120px;
            box-sizing: border-box;
            width: 100%;
        }

        /* Responsive padding for iPhone 12 and smaller */
        @media screen and (max-width: 375px) {
            .calendar-view {
                padding: 55px 10px 120px;
            }
        }

        .calendar-view.active {
            display: block;
        }

        .calendar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            padding: 0 10px;
        }

        .calendar-nav-btn {
            background: rgba(255, 255, 255, 0.1);
            border: none;
            color: #667eea;
            font-size: 18px;
            padding: 12px;
            border-radius: 8px;
            cursor: pointer;
        }

        .calendar-month {
            font-size: 22px;
            font-weight: 600;
            color: #ffffff;
        }

        .calendar-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 1px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            overflow: hidden;
        }

        .calendar-day-header {
            background: rgba(255, 255, 255, 0.05);
            color: #999;
            padding: 12px 4px;
            text-align: center;
            font-size: 12px;
            font-weight: 600;
        }

        .calendar-day {
            background: rgba(255, 255, 255, 0.03);
            padding: 12px 4px;
            min-height: 45px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            cursor: pointer;
            transition: background 0.3s ease;
        }

        .calendar-day:active {
            background: rgba(255, 255, 255, 0.1);
        }

        .calendar-day.today {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            font-weight: 600;
        }

        .calendar-day.other-month {
            color: #444;
        }

        .calendar-day.selected {
            background: rgba(102, 126, 234, 0.3);
            color: #667eea;
            font-weight: 600;
        }

        /* Stats View */
        .stats-view {
            display: none;
            padding: 60px 15px 120px;
            box-sizing: border-box;
            width: 100%;
        }

        /* Responsive padding for iPhone 12 and smaller */
        @media screen and (max-width: 375px) {
            .stats-view {
                padding: 55px 10px 120px;
            }
        }

        .stats-view.active {
            display: block;
        }

        .stats-header {
            text-align: center;
            margin-bottom: 40px;
        }

        .stats-header h2 {
            font-size: 28px;
            font-weight: 300;
            color: #ffffff;
            margin-bottom: 10px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            padding: 24px;
            text-align: center;
        }

        .stat-number {
            font-size: 32px;
            font-weight: 600;
            color: #667eea;
            margin-bottom: 8px;
        }

                 .stat-label {
            font-size: 14px;
            color: #999;
            font-weight: 500;
        }

        /* Voice Recording Modal */
        .voice-modal {
            position: fixed;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 100%;
            max-width: 390px;
            height: 100vh;
            background: #15202B;
            z-index: 200;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        .voice-modal.active {
            display: flex;
        }

        .voice-animation {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 40px;
            position: relative;
            cursor: pointer;
            transition: transform 0.3s ease;
        }

        .voice-animation:active {
            transform: scale(0.95);
        }

        .voice-animation.recording {
            animation: voicePulse 1s infinite;
        }

        .voice-animation::before {
            content: '';
            position: absolute;
            width: 140px;
            height: 140px;
            border: 2px solid rgba(102, 126, 234, 0.3);
            border-radius: 50%;
        }

        .voice-animation.recording::before {
            animation: ripple 1.5s infinite;
        }

        @keyframes voicePulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        @keyframes ripple {
            0% { transform: scale(1); opacity: 1; }
            100% { transform: scale(1.3); opacity: 0; }
        }

        .voice-animation i {
            font-size: 40px;
            color: white;
        }

        .voice-status {
            text-align: center;
            margin-bottom: 30px;
        }

        .voice-status h3 {
            font-size: 24px;
            font-weight: 300;
            color: #ffffff;
            margin-bottom: 10px;
        }

        .voice-status p {
            color: #999;
            font-size: 16px;
            line-height: 1.5;
        }

        .voice-transcript {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 20px;
            margin: 20px;
            min-height: 100px;
            max-height: 200px;
            overflow-y: auto;
        }

        .voice-transcript-text {
            color: #ffffff;
            font-size: 16px;
            line-height: 1.5;
        }

        .voice-controls {
            display: flex;
            gap: 20px;
            margin-top: 40px;
        }

        .voice-control-btn {
            padding: 16px 24px;
            border-radius: 12px;
            border: none;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-stop {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a24 100%);
            color: white;
        }

        .btn-process {
            background: linear-gradient(135deg, #51cf66 0%, #37b24d 100%);
            color: white;
        }

        .btn-cancel {
            background: rgba(255, 255, 255, 0.1);
            color: #999;
        }

        /* AI Chat Modal */
        .ai-chat-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            width: 100vw;
            height: 100vh;
            background: #15202B;
            z-index: 200;
            display: none;
            flex-direction: column;
            overflow: hidden;
            box-sizing: border-box;
        }

        /* Responsive modal for larger screens */
        @media screen and (min-width: 415px) {
            .ai-chat-modal {
                left: 50%;
                transform: translateX(-50%);
                max-width: 428px;
                width: 100%;
            }
        }

        .ai-chat-modal.active {
            display: flex;
        }

        /* Make chat input more visible on mobile */
        .ai-chat-modal.active .chat-input {
            color: white !important;
            -webkit-text-fill-color: white !important;
            background: rgba(255, 255, 255, 0.1) !important;
            border: 1px solid rgba(255, 255, 255, 0.3) !important;
        }

        .chat-header {
            padding: 25px 20px 15px; /* Significantly reduced padding */
            text-align: center;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1) 0%, rgba(118, 75, 162, 0.1) 100%);
        }

        .chat-header h3 {
            font-size: 18px; /* Smaller header text */
            font-weight: 300;
            color: #ffffff;
            margin-bottom: 3px; /* Reduced margin */
        }

        .chat-header p {
            color: #999;
            font-size: 12px; /* Smaller subtitle */
        }

        .chat-messages {
            flex: 1;
            padding: 15px 20px; /* Reduced top/bottom padding */
            padding-bottom: 200px; /* Normal padding since tasks are now fixed */
            overflow-y: auto;
            overflow-x: hidden;
            -webkit-overflow-scrolling: touch;
            display: flex;
            flex-direction: column;
            gap: 8px; /* Reduced gap between messages to save space */
            overscroll-behavior: contain;
            height: auto;
            max-height: calc(100vh - 200px); /* Normal height */
            min-height: 300px;
            scroll-behavior: smooth;
            /* Force scroll container properties */
            position: relative;
            z-index: 1;
        }

        /* Responsive layout for different screen sizes */
        @media screen and (max-width: 428px) {
            .detected-tasks-container {
                left: 10px;
                right: 10px;
                bottom: 180px;
            }
        }

        @media screen and (max-height: 900px) {
            .chat-messages {
                max-height: calc(100vh - 200px);
                padding-bottom: 200px;
            }
            .detected-tasks-container {
                bottom: 185px;
            }
            .chat-input-bar {
                bottom: 130px;
            }
        }

        @media screen and (max-height: 800px) {
            .chat-messages {
                max-height: calc(100vh - 190px);
                padding-bottom: 180px;
            }
            .detected-tasks-container {
                bottom: 175px;
            }
            .chat-input-bar {
                bottom: 125px;
            }
        }

        @media screen and (max-height: 700px) {
            .chat-messages {
                max-height: calc(100vh - 180px);
                padding-bottom: 160px;
            }
            .detected-tasks-container {
                bottom: 165px;
            }
            .chat-input-bar {
                bottom: 120px;
            }
        }
        
        @media screen and (max-height: 600px) {
            .chat-messages {
                max-height: calc(100vh - 170px);
                padding-bottom: 140px;
            }
            .detected-tasks-container {
                bottom: 155px;
            }
            .chat-input-bar {
                bottom: 110px;
            }
        }

        .ai-message,
        .user-message {
            display: flex;
            max-width: 80%; /* Slightly more compact */
        }

        .ai-message {
            align-self: flex-start;
        }

        .user-message {
            align-self: flex-end;
        }

        .message-bubble {
            padding: 8px 12px; /* Reduced padding by ~30% */
            border-radius: 12px; /* Smaller border radius */
            font-size: 13px; /* Smaller font size */
            line-height: 1.2; /* Tighter line height */
            word-wrap: break-word;
        }

        .ai-bubble {
            background: rgba(102, 126, 234, 0.2);
            color: #ffffff;
            border-bottom-left-radius: 6px;
            max-height: 150px; /* Limit AI message height */
            overflow-y: auto; /* Allow scrolling if too long */
        }

        .ai-bubble i {
            color: #667eea;
            margin-right: 8px;
            font-size: 14px;
        }

        .user-bubble {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-bottom-right-radius: 6px;
        }

        .chat-input-container {
            padding: 15px 20px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            gap: 12px;
            align-items: center;
            background: rgba(21, 32, 43, 0.95);
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            z-index: 100;
            backdrop-filter: blur(10px);
            box-sizing: border-box;
            min-height: 80px;
            padding-bottom: max(15px, env(safe-area-inset-bottom));
        }

        /* Responsive positioning for larger screens */
        @media screen and (min-width: 415px) {
            .chat-input-container {
                left: 50%;
                transform: translateX(-50%);
                max-width: 428px;
                width: 100%;
            }
            
            .detected-tasks-container {
                max-width: 388px;
                margin: 15px auto;
            }
        }
        
        /* Mobile responsive styling for detected tasks */
        @media screen and (max-width: 414px) {
            .detected-tasks-container {
                margin: 15px 0 !important;
                padding: 12px !important;
                border-radius: 8px !important;
            }
        }

        .chat-input {
            flex: 1;
            padding: 14px 18px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 25px;
            color: #ffffff;
            font-size: 15px;
            outline: none;
            transition: border-color 0.3s ease;
            -webkit-text-fill-color: #ffffff;
            -webkit-opacity: 1;
            -webkit-appearance: none;
            appearance: none;
            caret-color: #ffffff;
        }

        .chat-input:focus {
            border-color: #667eea;
            background: rgba(255, 255, 255, 0.15);
            color: #ffffff;
            -webkit-text-fill-color: #ffffff;
        }

        .chat-input::placeholder {
            color: #666;
        }

        /* Make chat input more visible on mobile */
        .ai-chat-modal.active .chat-input {
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.3) !important;
            border: 2px solid rgba(255, 255, 255, 0.4) !important;
            background: rgba(255, 255, 255, 0.2) !important;
        }

        /* Detected Tasks Styling - Fixed position above input bar */
        .detected-tasks-container {
            position: fixed;
            bottom: 190px; /* Position directly above input bar */
            left: 15px;
            right: 15px;
            background: rgba(102, 126, 234, 0.25);
            border: 2px solid rgba(102, 126, 234, 0.5);
            border-radius: 12px;
            padding: 15px;
            animation: slideDown 0.3s ease-out;
            z-index: 75; /* Higher than input bar z-index (60) */
            pointer-events: auto;
            touch-action: auto;
            display: none;
            visibility: visible;
            opacity: 1;
            backdrop-filter: blur(15px);
            box-sizing: border-box;
            box-shadow: 0 8px 32px rgba(102, 126, 234, 0.4);
            max-width: 400px;
            margin: 0 auto;
        }

        .detected-tasks-header {
            display: flex;
            align-items: center;
            gap: 8px;
            color: #667eea;
            font-weight: 600;
            font-size: 14px;
            margin-bottom: 12px;
        }

        .detected-tasks-header i {
            font-size: 16px;
        }

        .detected-tasks-list {
            margin-bottom: 15px;
            min-height: 50px;
            position: relative;
            z-index: 1;
            /* Debug styling to make it visible */
            /* border: 2px solid red; */
        }

        .detected-task-item {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            padding: 10px 12px;
            margin-bottom: 8px;
            color: #ffffff;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .detected-task-item:last-child {
            margin-bottom: 0;
        }

        .detected-task-item i {
            color: #667eea;
            font-size: 14px;
        }

        .detected-tasks-actions {
            display: flex;
            gap: 12px;
            margin-top: 15px;
            padding: 12px 0 0 0; /* Simple top padding only */
            border-top: 1px solid rgba(102, 126, 234, 0.4);
        }

        .approve-tasks-btn {
            flex: 1;
            padding: 14px 18px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            border-radius: 10px;
            color: white;
            font-weight: 700;
            font-size: 15px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            transition: all 0.3s ease;
            touch-action: manipulation;
            -webkit-tap-highlight-color: rgba(255, 255, 255, 0.2);
            position: relative;
            z-index: 80;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.6);
            min-height: 48px;
        }

        .approve-tasks-btn:active {
            transform: scale(0.95);
            background: linear-gradient(135deg, #5a6edb 0%, #6a4193 100%);
        }

        .dismiss-tasks-btn {
            padding: 14px 18px;
            background: rgba(255, 255, 255, 0.15);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            color: #ffffff;
            font-weight: 600;
            font-size: 15px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            transition: all 0.3s ease;
            touch-action: manipulation;
            -webkit-tap-highlight-color: rgba(255, 255, 255, 0.2);
            position: relative;
            z-index: 80;
            min-height: 48px;
            box-shadow: 0 2px 10px rgba(255, 255, 255, 0.2);
        }

        .dismiss-tasks-btn:active {
            transform: scale(0.95);
            background: rgba(255, 255, 255, 0.05);
        }

        .send-btn {
            width: 45px;
            height: 45px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            color: white;
            font-size: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }



        .send-btn:active {
            transform: scale(0.95);
        }

        .send-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .create-tasks-btn {
            background: linear-gradient(135deg, #51cf66 0%, #37b24d 100%);
            color: white;
            border: none;
            padding: 10px 16px;
            border-radius: 20px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 6px;
            transition: all 0.3s ease;
            white-space: nowrap;
        }

        .create-tasks-btn:active {
            transform: scale(0.95);
        }

        .create-tasks-btn i {
            font-size: 11px;
        }

        .typing-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            color: #667eea;
            font-size: 14px;
            font-style: italic;
            padding: 10px 0;
        }

        .typing-dots {
            display: flex;
            gap: 3px;
        }

        .typing-dots span {
            width: 4px;
            height: 4px;
            background: #667eea;
            border-radius: 50%;
            animation: typingBounce 1.4s infinite ease-in-out;
        }

        .typing-dots span:nth-child(2) {
            animation-delay: 0.2s;
        }

        .typing-dots span:nth-child(3) {
            animation-delay: 0.4s;
        }

        @keyframes typingBounce {
            0%, 80%, 100% { transform: scale(0.8); opacity: 0.5; }
            40% { transform: scale(1); opacity: 1; }
        }

        /* Day Schedule View */
        .day-schedule-view {
            display: none;
            min-height: 100vh;
            padding: 0;
            background: #15202B;
        }

        .day-schedule-view.active {
            display: block;
        }

        .day-schedule-header {
            position: fixed;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 100%;
            max-width: 390px;
            height: 80px;
            background: rgba(21, 32, 43, 0.95);
            backdrop-filter: blur(20px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
            z-index: 100;
        }

        .back-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
            border: none;
            color: #667eea;
            font-size: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .back-btn:active {
            transform: scale(0.95);
            background: rgba(255, 255, 255, 0.15);
        }

        .day-schedule-title {
            text-align: center;
            flex: 1;
        }

        .day-schedule-title h2 {
            font-size: 18px;
            font-weight: 600;
            color: #ffffff;
            margin-bottom: 2px;
        }

        .day-schedule-title p {
            font-size: 12px;
            color: #999;
        }

        .add-time-task-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            color: white;
            font-size: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .add-time-task-btn:active {
            transform: scale(0.95);
        }

        .time-slots-container {
            padding: 90px 0 150px;
            height: 100vh;
            overflow-y: auto;
        }

        .time-slot {
            display: flex;
            padding: 0 20px;
            margin-bottom: 1px;
            background: rgba(255, 255, 255, 0.02);
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            min-height: 60px;
            align-items: stretch;
        }

        .time-slot:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        .time-label {
            width: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: 600;
            color: #666;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
            margin-right: 15px;
        }

        .time-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            padding: 10px 0;
            cursor: pointer;
        }

        .time-content.empty {
            align-items: center;
            justify-content: center;
            color: #666;
            font-style: italic;
        }

        .time-content.empty:hover {
            color: #667eea;
        }

        .scheduled-task {
            background: rgba(102, 126, 234, 0.15);
            border-left: 4px solid #667eea;
            padding: 8px 12px;
            border-radius: 8px;
            margin: 4px 0;
        }

        .scheduled-task-title {
            font-size: 14px;
            font-weight: 600;
            color: #ffffff;
            margin-bottom: 4px;
        }

        .scheduled-task-duration {
            font-size: 11px;
            color: #667eea;
        }

        .scheduled-task-actions {
            display: flex;
            gap: 8px;
            margin-top: 8px;
        }

        .task-action-btn {
            background: none;
            border: none;
            color: #667eea;
            font-size: 12px;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 4px;
            transition: background 0.3s ease;
        }

        .task-action-btn:hover {
            background: rgba(102, 126, 234, 0.2);
        }

        .task-action-btn.complete {
            color: #51cf66;
        }

        .task-action-btn.delete {
            color: #ff6b6b;
        }

        /* Time Task Modal */
        .time-task-modal {
            position: fixed;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 100%;
            max-width: 390px;
            height: 100vh;
            background: #15202B;
            z-index: 200;
            display: none;
            flex-direction: column;
        }

        .time-task-modal.active {
            display: flex;
        }

        .time-task-header {
            padding: 60px 20px 30px;
            text-align: center;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .time-task-header h3 {
            font-size: 24px;
            font-weight: 300;
            color: #ffffff;
            margin-bottom: 8px;
        }

        .time-task-header p {
            color: #999;
            font-size: 14px;
        }

        .time-task-form {
            flex: 1;
            padding: 30px 20px;
        }

        .form-group {
            margin-bottom: 25px;
        }

        .form-group label {
            display: block;
            color: #ffffff;
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 8px;
        }

        .time-task-input,
        .time-slot-select,
        .duration-select {
            width: 100%;
            padding: 15px 18px;
            background: rgba(255, 255, 255, 0.1) !important;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            color: #ffffff !important;
            font-size: 16px;
            outline: none;
            transition: all 0.3s ease;
            -webkit-text-fill-color: #ffffff !important;
            -webkit-opacity: 1 !important;
            -webkit-appearance: none !important;
            appearance: none !important;
            caret-color: #ffffff !important;
        }

        .time-task-input:focus,
        .time-slot-select:focus,
        .duration-select:focus {
            border-color: #667eea;
            background: rgba(255, 255, 255, 0.15) !important;
            color: #ffffff !important;
            -webkit-text-fill-color: #ffffff !important;
            -webkit-appearance: none !important;
            appearance: none !important;
            caret-color: #ffffff !important;
        }

        .time-task-input::placeholder {
            color: #666 !important;
        }

        select option {
            background: #15202B;
            color: #ffffff;
        }

        .time-task-actions {
            display: flex;
            gap: 15px;
            padding: 20px;
        }

        .time-task-btn {
            flex: 1;
            padding: 16px;
            border-radius: 12px;
            border: none;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
        }

        .time-task-btn.btn-cancel {
            background: rgba(255, 255, 255, 0.1);
            color: #999;
        }

        .time-task-btn.btn-schedule {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        /* Hour markers */
        .time-slot.hour-marker {
            background: rgba(255, 255, 255, 0.08);
            border-bottom: 2px solid rgba(102, 126, 234, 0.3);
        }

        .time-slot.hour-marker .time-label {
            color: #667eea;
            font-weight: 700;
        }
    </style>
</head>
<body>
    <div class="mobile-container">
        <!-- Status Bar -->
        <div class="status-bar">
            <span>MeMaster</span>
            <div class="sync-status offline" id="syncStatus">
                <i class="fas fa-wifi sync-icon" id="syncIcon"></i>
                <span id="syncText">Offline</span>
            </div>
        </div>

        <!-- Welcome Screen -->
        <div class="welcome-screen" id="welcomeScreen">
            <div class="app-logo">
                <i class="fas fa-crown"></i>
            </div>
            <h1>MeMaster</h1>
            <p>Master your daily goals<br>and become the best version of yourself</p>
            
            <div class="welcome-actions">
                <button class="welcome-btn btn-primary" onclick="showMainApp()">
                    <i class="fas fa-rocket" style="margin-right: 8px;"></i>
                    Get Started
                </button>
                <button class="welcome-btn btn-secondary" onclick="showMainApp()">
                    <i class="fas fa-sign-in-alt" style="margin-right: 8px;"></i>
                    Continue
                </button>
            </div>
        </div>

        <!-- Main App Screen -->
        <div class="main-screen" id="mainScreen">
            <div class="question-header">
                <h2>What would you like to get done today?</h2>
            </div>

            <div class="add-task-container">
                <button class="add-task-btn" onclick="showInputModal()">
                    Add Task
                </button>
            </div>



            <ul class="todo-list" id="todoList">
                <!-- Todos will be populated here -->
            </ul>
        </div>

        <!-- Calendar View -->
        <div class="calendar-view" id="calendarView">
            <div class="calendar-header">
                <button class="calendar-nav-btn" onclick="previousMonth()">
                    <i class="fas fa-chevron-left"></i>
                </button>
                <div class="calendar-month" id="calendarMonth">January 2024</div>
                <button class="calendar-nav-btn" onclick="nextMonth()">
                    <i class="fas fa-chevron-right"></i>
                </button>
            </div>
            <div class="calendar-grid" id="calendarGrid">
                <!-- Calendar will be generated -->
            </div>
        </div>

        <!-- Stats View -->
        <div class="stats-view" id="statsView">
            <div class="stats-header">
                <h2>Your Progress</h2>
                <p>Track your daily achievements</p>
            </div>
            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-number" id="totalTasksCount">0</div>
                    <div class="stat-label">Total Tasks</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="completedTasksCount">0</div>
                    <div class="stat-label">Completed</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="streakCount">0</div>
                    <div class="stat-label">Day Streak</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="completionPercentage">0%</div>
                    <div class="stat-label">Success Rate</div>
                </div>
            </div>
        </div>

        <!-- Day Schedule View -->
        <div class="day-schedule-view" id="dayScheduleView">
            <div class="day-schedule-header">
                <button class="back-btn" onclick="closeDaySchedule()">
                    <i class="fas fa-arrow-left"></i>
                </button>
                <div class="day-schedule-title">
                    <h2 id="dayScheduleDate">Today's Schedule</h2>
                    <p id="dayScheduleSubtitle">Plan your perfect day</p>
                </div>
                <button class="add-time-task-btn" onclick="showTimeTaskModal()">
                    <i class="fas fa-plus"></i>
                </button>
            </div>
            
            <div class="time-slots-container" id="timeSlotsContainer">
                <!-- Time slots will be generated here -->
            </div>
        </div>

        <!-- Bottom Navigation -->
        <div class="bottom-nav">
            <div class="nav-item active" onclick="showView('main')">
                <i class="fas fa-tasks"></i>
                <span>Today</span>
            </div>
            <div class="nav-item" onclick="showView('calendar')">
                <i class="fas fa-calendar-alt"></i>
                <span>Calendar</span>
            </div>
            <div class="nav-item" onclick="showView('stats')">
                <i class="fas fa-chart-bar"></i>
                <span>Progress</span>
            </div>
        </div>

        <!-- AI Suggestions Modal -->
        <div class="ai-suggestions-modal" id="aiModal">
            <button class="close-modal" onclick="closeAIModal()">
                <i class="fas fa-times"></i>
            </button>
            <div class="modal-header">
                <h3>AI Suggestions</h3>
                <p>Smart recommendations for your day</p>
            </div>
            <div class="suggestions-list" id="suggestionsList">
                <!-- AI suggestions will be populated here -->
            </div>
        </div>

                 <!-- Input Modal -->
        <div class="input-modal" id="inputModal">
            <button class="close-modal" onclick="closeInputModal()">
                <i class="fas fa-times"></i>
            </button>
            <div class="input-header">
                <h3>Add New Task</h3>
                <input type="text" class="task-input" id="taskInput" placeholder="What do you want to accomplish?">
            </div>
            <div class="input-actions">
                <button class="input-btn btn-cancel" onclick="closeInputModal()">Cancel</button>
                <button class="input-btn btn-add" onclick="addTask()">Add Task</button>
            </div>
        </div>

                 <!-- Voice Recording Modal -->
        <div class="voice-modal" id="voiceModal">
            <div class="voice-animation" id="voiceAnimation" onclick="handleVoiceAnimationClick()">
                <i class="fas fa-microphone"></i>
            </div>
            
            <div class="voice-status" id="voiceStatus">
                <h3>Tap to start speaking</h3>
                <p>Tell me what you want to get done today.<br>I'll create a todo list for you!</p>
            </div>

            <div class="voice-transcript" id="voiceTranscript" style="display: none;">
                <div class="voice-transcript-text" id="transcriptText"></div>
            </div>

            <div class="voice-controls">
                <button class="voice-control-btn btn-cancel" onclick="cancelVoiceInput()">
                    Cancel
                </button>
                <button class="voice-control-btn btn-stop" id="voiceStopBtn" onclick="stopVoiceInput()" style="display: none;">
                    Stop Recording
                </button>
                <button class="voice-control-btn btn-process" id="voiceProcessBtn" onclick="processVoiceInput()" style="display: none;">
                    Create Tasks
                </button>
            </div>
        </div>

        <!-- Time Task Modal -->
        <div class="time-task-modal" id="timeTaskModal">
            <button class="close-modal" onclick="closeTimeTaskModal()">
                <i class="fas fa-times"></i>
            </button>
            <div class="time-task-header">
                <h3>Schedule Task</h3>
                <p>Add a task to your daily schedule</p>
            </div>
            
            <div class="time-task-form">
                <div class="form-group">
                    <label>Task Description</label>
                    <input type="text" class="time-task-input" id="timeTaskInput" placeholder="What do you want to do?">
                </div>
                
                <div class="form-group">
                    <label>Time Slot</label>
                    <select class="time-slot-select" id="timeSlotSelect">
                        <!-- Time options will be populated -->
                    </select>
                </div>
                
                <div class="form-group">
                    <label>Duration</label>
                    <select class="duration-select" id="durationSelect">
                        <option value="15">15 minutes</option>
                        <option value="30" selected>30 minutes</option>
                        <option value="60">1 hour</option>
                        <option value="90">1.5 hours</option>
                        <option value="120">2 hours</option>
                        <option value="180">3 hours</option>
                    </select>
                </div>
            </div>
            
            <div class="time-task-actions">
                <button class="time-task-btn btn-cancel" onclick="closeTimeTaskModal()">Cancel</button>
                <button class="time-task-btn btn-schedule" onclick="scheduleTimeTask()">Schedule Task</button>
            </div>
        </div>

         <!-- AI Chat Modal -->
         <div class="ai-chat-modal" id="aiChatModal">
             <div class="chat-header">
                 <button class="close-modal" onclick="closeAIChat()">
                     <i class="fas fa-times"></i>
                 </button>
                 <button class="close-modal" onclick="window.resetAITyping()" style="right: 60px; background: rgba(255,100,100,0.8); font-size: 12px;" title="Reset AI if stuck">
                     <i class="fas fa-redo"></i>
                 </button>
                 <h3>AI Assistant</h3>
                 <p>Let's plan your perfect day together!</p>
             </div>
             
             <div class="chat-messages" id="chatMessages">
                 <div class="ai-message">
                     <div class="message-bubble ai-bubble">
                         <i class="fas fa-robot"></i>
                         <span>Hi! What would you like to accomplish today?</span>
                     </div>
                 </div>
             </div>
             
                         <!-- Detected Tasks Display -->
            <div class="detected-tasks-container" id="detectedTasksContainer" style="display: none;">
                <div class="detected-tasks-header">
                    <i class="fas fa-tasks"></i>
                    <span>I found these tasks. Should I add them to your planner?</span>
                </div>
                <div class="detected-tasks-list" id="detectedTasksList"></div>
                <div class="detected-tasks-actions">
                    <button class="approve-tasks-btn" onclick="approveDetectedTasks()">
                        <i class="fas fa-check"></i>
                        Add These Tasks
                    </button>
                                    <button class="dismiss-tasks-btn" onclick="dismissDetectedTasks()">
                    <i class="fas fa-times"></i>
                    Not Now
                </button>
            </div>

        </div>

            <div class="chat-input-container">
                <input type="text" class="chat-input" id="chatInput" placeholder="Tell me what's on your mind..." 
                       autocomplete="off" autocorrect="off" autocapitalize="sentences" spellcheck="true"
                       style="color: white !important; -webkit-text-fill-color: white !important; background: rgba(255, 255, 255, 0.1) !important; border: 1px solid rgba(255, 255, 255, 0.3) !important; font-size: 16px !important; font-weight: 500 !important;"
                       onkeypress="if(event.key==='Enter'){sendMessage();}"
                       onfocus="this.style.setProperty('background', 'rgba(255,255,255,0.15)', 'important'); this.style.setProperty('color', 'white', 'important'); this.style.setProperty('-webkit-text-fill-color', 'white', 'important');"
                       onblur="this.style.setProperty('background', 'rgba(255,255,255,0.1)', 'important');"
                       oninput="this.style.setProperty('color', 'white', 'important'); this.style.setProperty('-webkit-text-fill-color', 'white', 'important');">
                <button class="send-btn" id="sendBtn" onclick="sendMessage()">
                    <i class="fas fa-paper-plane"></i>
                </button>
            </div>
         </div>

         <!-- Chat Input Bar -->
        <div class="chat-input-bar">
            <input type="text" class="bottom-chat-input" id="bottomChatInput" placeholder="Ask AI to help plan your day..." 
                   style="color: white !important; -webkit-text-fill-color: white !important; background: rgba(255, 255, 255, 0.1) !important; border: 1px solid rgba(255, 255, 255, 0.2) !important;"
                   onfocus="this.style.setProperty('background', 'rgba(255,255,255,0.15)', 'important'); this.style.setProperty('color', 'white', 'important'); this.style.setProperty('-webkit-text-fill-color', 'white', 'important');"
                   onblur="this.style.setProperty('background', 'rgba(255,255,255,0.1)', 'important');"
                   oninput="this.style.setProperty('color', 'white', 'important'); this.style.setProperty('-webkit-text-fill-color', 'white', 'important');">
            <button class="voice-input-btn" onclick="startVoiceInput()" title="Speak your tasks">
                <i class="fas fa-microphone"></i>
            </button>
        </div>

        
     </div>

    <script>
        // Global variables
        let currentDate = new Date();
        let selectedDate = new Date();
        let todos = []; // Will be loaded from DataLayer
        let scheduledTasks = JSON.parse(localStorage.getItem('memaster_scheduled_tasks')) || {};
        let currentView = 'main';
        let recognition = null;
        let isRecording = false;
        let voiceTranscript = '';
        let selectedTimeSlot = null;

        // Initialize app
        async function initializeApp() {
            console.log('🚀 Initializing MeMaster...');
            
            // Load todos from DataLayer
            try {
                todos = await DataLayer.loadTodos();
                console.log('📋 Loaded', todos.length, 'todos');
            } catch (error) {
                console.error('❌ Failed to load todos:', error);
                todos = []; // Fallback to empty array
            }
            
            renderTodos();
            updateStats();
            updateSyncStatus();
        }

        function showMainApp() {
            document.getElementById('welcomeScreen').style.display = 'none';
            document.getElementById('mainScreen').classList.add('active');
            initializeApp();
        }

        // View management
        function showView(view) {
            // Close any open swipes
            closeAllSwipes();
            
            // Hide all views
            document.querySelectorAll('.main-screen, .calendar-view, .stats-view, .day-schedule-view').forEach(v => {
                v.classList.remove('active');
            });
            
            // Remove active from nav items
            document.querySelectorAll('.nav-item').forEach(item => {
                item.classList.remove('active');
            });
            
            // Show selected view and activate nav
            if (view === 'main') {
                document.getElementById('mainScreen').classList.add('active');
                renderTodos();
            } else if (view === 'calendar') {
                document.getElementById('calendarView').classList.add('active');
                renderCalendar();
            } else if (view === 'stats') {
                document.getElementById('statsView').classList.add('active');
                updateStats();
            }
            
            // Activate nav item
            event.target.closest('.nav-item').classList.add('active');
            currentView = view;
        }

        // Todo functions
        function renderTodos() {
            const todoList = document.getElementById('todoList');
            const dateKey = selectedDate.toISOString().split('T')[0];
            const todayTodos = todos.filter(todo => todo.date === dateKey);
            
            // Sort todos: uncompleted first, then completed
            const sortedTodos = todayTodos.sort((a, b) => {
                if (a.completed === b.completed) {
                    // If both have same completion status, maintain original order
                    return new Date(a.createdAt) - new Date(b.createdAt);
                }
                // Uncompleted tasks come first (false < true)
                return a.completed ? 1 : -1;
            });
            
            todoList.innerHTML = '';
            
            sortedTodos.forEach((todo, index) => {
                const li = document.createElement('li');
                li.className = `todo-item ${todo.completed ? 'completed' : ''}`;
                li.dataset.todoId = todo.id;
                
                li.innerHTML = `
                    <div class="todo-item-wrapper">
                        <div class="todo-item-content" 
                             onclick="handleTodoClick(event, '${todo.id}')"
                             ontouchstart="handleTouchStart(event, '${todo.id}')"
                             ontouchmove="handleTouchMove(event)"
                             ontouchend="handleTouchEnd(event)">
                            <div class="todo-number">${index + 1}.</div>
                            <div class="todo-text">${todo.text}</div>
                        </div>
                        <div class="todo-checkbox ${todo.completed ? 'checked' : ''}" 
                             onclick="handleCheckboxClick(event, '${todo.id}')"></div>
                    </div>
                    <div class="todo-delete-area" onclick="deleteTodoWithSlide('${todo.id}')">
                        <i class="fas fa-trash todo-delete-icon"></i>
                    </div>
                `;
                
                todoList.appendChild(li);
            });
        }

        async function addTask() {
            const input = document.getElementById('taskInput');
            const text = input.value.trim();
            
            if (text) {
                const todo = {
                    id: Date.now().toString(),
                    text: text,
                    completed: false,
                    date: selectedDate.toISOString().split('T')[0],
                    createdAt: new Date().toISOString()
                };
                
                todos.push(todo);
                
                // Save using DataLayer
                try {
                    await DataLayer.saveTodos(todos);
                    console.log('✅ Task added and saved');
                } catch (error) {
                    console.error('❌ Failed to save task:', error);
                    if (!isOnline && isFirebaseEnabled) {
                        DataLayer.queueSync('add', todo);
                    }
                }
                
                input.value = '';
                closeInputModal();
                renderTodos();
                updateStats();
            }
        }

        function handleCheckboxClick(event, id) {
            console.log('🔘 Checkbox clicked for task id:', id);
            event.stopPropagation();
            event.preventDefault();
            event.stopImmediatePropagation();
            
            // Add a small delay to ensure the event is fully handled
            setTimeout(() => {
                toggleTodo(id);
            }, 10);
        }

        async function toggleTodo(id) {
            console.log('🔄 Toggling task with id:', id);
            const todo = todos.find(t => t.id === id);
            if (todo) {
                console.log('📝 Task found:', todo.text, 'Current completed state:', todo.completed);
                todo.completed = !todo.completed;
                console.log('📝 New completed state:', todo.completed);
                
                // Save using DataLayer
                try {
                    await DataLayer.saveTodos(todos);
                    console.log('✅ Task toggled and saved');
                } catch (error) {
                    console.error('❌ Failed to save task toggle:', error);
                    if (!isOnline && isFirebaseEnabled) {
                        DataLayer.queueSync('toggle', { id, completed: todo.completed });
                    }
                }
                
                renderTodos();
                updateStats();
            } else {
                console.error('❌ Task not found with id:', id);
            }
        }

        function handleTodoClick(event, todoId) {
            event.preventDefault();
            const todoItem = event.target.closest('.todo-item');
            
            // Close all other swiped items first
            document.querySelectorAll('.todo-item.swiped').forEach(item => {
                if (item !== todoItem) {
                    item.classList.remove('swiped');
                }
            });
            
            // Toggle swipe state for clicked item
            todoItem.classList.toggle('swiped');
        }

        // Touch support for mobile swipe gestures
        let touchStartX = null;
        let touchStartY = null;
        let currentTouchItem = null;

        function handleTouchStart(event, todoId) {
            const touch = event.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            currentTouchItem = event.target.closest('.todo-item');
        }

        function handleTouchMove(event) {
            if (!touchStartX || !currentTouchItem) return;
            
            const touch = event.touches[0];
            const deltaX = touchStartX - touch.clientX;
            const deltaY = touchStartY - touch.clientY;
            
            // Only process horizontal swipes (ignore vertical scrolling)
            if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > 30) {
                event.preventDefault();
                
                if (deltaX > 0) { // Swiping left
                    currentTouchItem.classList.add('swiped');
                    // Close other swipes
                    document.querySelectorAll('.todo-item.swiped').forEach(item => {
                        if (item !== currentTouchItem) {
                            item.classList.remove('swiped');
                        }
                    });
                }
            }
        }

        function handleTouchEnd(event) {
            touchStartX = null;
            touchStartY = null;
            currentTouchItem = null;
        }

        async function deleteTodoWithSlide(id) {
            console.log('Deleting task with id:', id, 'type:', typeof id);
            const todoItem = document.querySelector(`.todo-item[data-todo-id="${id}"]`);
            
            if (!todoItem) {
                console.error('Todo item not found for id:', id);
                showToast('Error: Task not found');
                return;
            }
            
            // Add slide out animation
            todoItem.style.transform = 'translateX(-100%)';
            todoItem.style.opacity = '0';
            
            // Remove from array and update storage after animation
            setTimeout(async () => {
                console.log('Before deletion, todos count:', todos.length);
                const originalLength = todos.length;
                
                // Convert both ids to strings for comparison to handle type mismatches
                todos = todos.filter(t => t.id.toString() !== id.toString());
                
                console.log('After deletion, todos count:', todos.length);
                
                if (todos.length === originalLength) {
                    console.error('Task was not removed from array. ID mismatch?');
                    console.log('Available todo ids:', todos.map(t => `${t.id} (${typeof t.id})`));
                }
                
                // Save using DataLayer
                try {
                    await DataLayer.saveTodos(todos);
                    console.log('✅ Task deleted and saved');
                } catch (error) {
                    console.error('❌ Failed to save task deletion:', error);
                    if (!isOnline && isFirebaseEnabled) {
                        DataLayer.queueSync('delete', { id });
                    }
                }
                
                renderTodos();
                updateStats();
                showToast('Task deleted');
            }, 300);
        }

        // Close swipes when clicking elsewhere
        function closeAllSwipes() {
            document.querySelectorAll('.todo-item.swiped').forEach(item => {
                item.classList.remove('swiped');
            });
        }

        // Modal functions
        function showInputModal() {
            document.getElementById('inputModal').classList.add('active');
            setTimeout(() => {
                document.getElementById('taskInput').focus();
            }, 300);
        }

        function closeInputModal() {
            document.getElementById('inputModal').classList.remove('active');
            document.getElementById('taskInput').value = '';
        }

        function showAISuggestions() {
            const modal = document.getElementById('aiModal');
            const suggestionsList = document.getElementById('suggestionsList');
            
            // Generate AI suggestions based on time of day
            const hour = new Date().getHours();
            let suggestions = [];
            
            if (hour < 10) {
                suggestions = [
                    'Review your goals for the day',
                    'Do a 10-minute morning meditation',
                    'Plan your most important task',
                    'Check and respond to messages',
                    'Prepare a healthy breakfast'
                ];
            } else if (hour < 14) {
                suggestions = [
                    'Focus on your most challenging task',
                    'Take a 15-minute break',
                    'Call someone important',
                    'Organize your workspace',
                    'Review project progress'
                ];
            } else if (hour < 18) {
                suggestions = [
                    'Complete pending tasks',
                    'Plan tomorrow\'s priorities',
                    'Take a walk outside',
                    'Follow up on communications',
                    'Prepare for evening activities'
                ];
            } else {
                suggestions = [
                    'Reflect on today\'s achievements',
                    'Prepare for tomorrow',
                    'Do a quick workout',
                    'Read for 30 minutes',
                    'Connect with family or friends'
                ];
            }
            
            suggestionsList.innerHTML = '';
            suggestions.forEach(suggestion => {
                const div = document.createElement('div');
                div.className = 'suggestion-item';
                div.innerHTML = `
                    <div class="suggestion-text">${suggestion}</div>
                    <button class="add-suggestion-btn" onclick="addSuggestionAsTodo('${suggestion}')">
                        Add
                    </button>
                `;
                suggestionsList.appendChild(div);
            });
            
            modal.classList.add('active');
        }

        function closeAIModal() {
            document.getElementById('aiModal').classList.remove('active');
        }

        async function addSuggestionAsTodo(suggestion) {
            const todo = {
                id: Date.now().toString(),
                text: suggestion,
                completed: false,
                date: selectedDate.toISOString().split('T')[0],
                createdAt: new Date().toISOString()
            };
            
            todos.push(todo);
            
            // Save using DataLayer
            try {
                await DataLayer.saveTodos(todos);
                console.log('✅ Suggestion added and saved');
            } catch (error) {
                console.error('❌ Failed to save suggestion:', error);
                if (!isOnline && isFirebaseEnabled) {
                    DataLayer.queueSync('add', todo);
                }
            }
            
            closeAIModal();
            renderTodos();
            updateStats();
        }

        // Calendar functions
        function renderCalendar() {
            const grid = document.getElementById('calendarGrid');
            const monthDisplay = document.getElementById('calendarMonth');
            
            monthDisplay.textContent = currentDate.toLocaleDateString('en-US', { 
                month: 'long', 
                year: 'numeric' 
            });
            
            grid.innerHTML = '';
            
            // Add day headers
            const dayHeaders = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
            dayHeaders.forEach(day => {
                const header = document.createElement('div');
                header.className = 'calendar-day-header';
                header.textContent = day;
                grid.appendChild(header);
            });
            
            // Generate calendar days
            const firstDay = new Date(currentDate.getFullYear(), currentDate.getMonth(), 1);
            const lastDay = new Date(currentDate.getFullYear(), currentDate.getMonth() + 1, 0);
            const startDate = new Date(firstDay);
            startDate.setDate(startDate.getDate() - firstDay.getDay());
            
            for (let i = 0; i < 42; i++) {
                const date = new Date(startDate);
                date.setDate(startDate.getDate() + i);
                
                const dayElement = document.createElement('div');
                dayElement.className = 'calendar-day';
                
                if (date.getMonth() !== currentDate.getMonth()) {
                    dayElement.classList.add('other-month');
                }
                
                if (date.toDateString() === new Date().toDateString()) {
                    dayElement.classList.add('today');
                }
                
                if (date.toDateString() === selectedDate.toDateString()) {
                    dayElement.classList.add('selected');
                }
                
                dayElement.textContent = date.getDate();
                dayElement.addEventListener('click', () => {
                    selectedDate = new Date(date);
                    renderCalendar();
                    
                    // Open day schedule view
                    openDaySchedule();
                });
                
                grid.appendChild(dayElement);
            }
        }

        function previousMonth() {
            currentDate.setMonth(currentDate.getMonth() - 1);
            renderCalendar();
        }

        function nextMonth() {
            currentDate.setMonth(currentDate.getMonth() + 1);
            renderCalendar();
        }

        // Stats functions
        function updateStats() {
            const allTodos = todos;
            const completedTodos = allTodos.filter(todo => todo.completed);
            const totalTasks = allTodos.length;
            const completedTasks = completedTodos.length;
            const completionRate = totalTasks > 0 ? Math.round((completedTasks / totalTasks) * 100) : 0;
            
            // Calculate streak (simplified)
            const streak = calculateStreak();
            
            document.getElementById('totalTasksCount').textContent = totalTasks;
            document.getElementById('completedTasksCount').textContent = completedTasks;
            document.getElementById('streakCount').textContent = streak;
            document.getElementById('completionPercentage').textContent = completionRate + '%';
        }

        function calculateStreak() {
            // Simplified streak calculation
            const today = new Date().toISOString().split('T')[0];
            const todayTodos = todos.filter(todo => todo.date === today);
            const todayCompleted = todayTodos.filter(todo => todo.completed);
            
            return todayCompleted.length > 0 ? 1 : 0; // Simplified for demo
        }

        // Voice Recognition Functions
        function initSpeechRecognition() {
            if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                recognition = new SpeechRecognition();
                
                recognition.continuous = true;
                recognition.interimResults = true;
                recognition.lang = 'en-US';

                recognition.onstart = function() {
                    isRecording = true;
                    updateVoiceUI('recording');
                };

                recognition.onresult = function(event) {
                    let transcript = '';
                    for (let i = event.resultIndex; i < event.results.length; i++) {
                        if (event.results[i].isFinal) {
                            transcript += event.results[i][0].transcript;
                        }
                    }
                    
                    if (transcript) {
                        voiceTranscript += transcript + ' ';
                        updateTranscriptDisplay();
                    }
                };

                recognition.onerror = function(event) {
                    console.error('Speech recognition error:', event.error);
                    updateVoiceUI('error');
                };

                recognition.onend = function() {
                    isRecording = false;
                    updateVoiceUI('stopped');
                };

                return true;
            }
            return false;
        }

        function startVoiceInput() {
            const modal = document.getElementById('voiceModal');
            const floatingBtn = document.querySelector('.floating-voice-btn');
            
            // Check if speech recognition is supported
            if (!initSpeechRecognition()) {
                alert('Speech recognition is not supported in your browser. Please try Chrome or Safari.');
                return;
            }

            // Reset state
            voiceTranscript = '';
            updateTranscriptDisplay();
            
            // Show modal
            modal.classList.add('active');
            updateVoiceUI('ready');
            
            // Start recording after a short delay
            setTimeout(() => {
                if (recognition) {
                    recognition.start();
                }
            }, 500);
        }

        function stopVoiceInput() {
            if (recognition && isRecording) {
                recognition.stop();
            }
        }

        function cancelVoiceInput() {
            if (recognition && isRecording) {
                recognition.stop();
            }
            
            voiceTranscript = '';
            document.getElementById('voiceModal').classList.remove('active');
            
            // Reset voice button state
            const voiceBtn = document.querySelector('.voice-input-btn');
            voiceBtn.classList.remove('recording');
            
            updateVoiceUI('ready');
        }

        async function processVoiceInput() {
            if (!voiceTranscript.trim()) {
                alert('No speech detected. Please try again.');
                return;
            }

            // Parse the transcript and create tasks
            const tasks = parseVoiceToTasks(voiceTranscript);
            
            if (tasks.length > 0) {
                // Add all tasks to the todo list
                tasks.forEach(taskText => {
                    const todo = {
                        id: Date.now().toString() + Math.random().toString(36).substr(2, 9),
                        text: taskText.trim(),
                        completed: false,
                        date: selectedDate.toISOString().split('T')[0],
                        createdAt: new Date().toISOString()
                    };
                    
                    todos.push(todo);
                });

                // Save using DataLayer
                try {
                    await DataLayer.saveTodos(todos);
                    console.log('✅ Voice tasks created and saved');
                } catch (error) {
                    console.error('❌ Failed to save voice tasks:', error);
                    if (!isOnline && isFirebaseEnabled) {
                        tasks.forEach(taskText => {
                            DataLayer.queueSync('add', {
                                id: Date.now().toString() + Math.random().toString(36).substr(2, 9),
                                text: taskText.trim(),
                                completed: false,
                                date: selectedDate.toISOString().split('T')[0],
                                createdAt: new Date().toISOString()
                            });
                        });
                    }
                }
                
                // Close modal and refresh UI
                document.getElementById('voiceModal').classList.remove('active');
                
                // Reset voice button state
                const voiceBtn = document.querySelector('.voice-input-btn');
                voiceBtn.classList.remove('recording');
                
                renderTodos();
                updateStats();
                
                // Show success message
                showToast(`Created ${tasks.length} tasks from your speech!`);
            } else {
                alert('Could not understand any tasks from your speech. Please try again.');
            }
        }

        function parseVoiceToTasks(transcript) {
            // Clean up the transcript
            let text = transcript.toLowerCase().trim();
            
            // Remove filler words and clean up
            text = text.replace(/\b(um|uh|er|ah|like|you know)\b/g, '');
            text = text.replace(/\s+/g, ' ').trim();
            
            // Split by common task separators
            const separators = [
                /\band then\b/g,
                /\balso\b/g,
                /\bnext\b/g,
                /\bafter that\b/g,
                /\bthen\b/g,
                /\bfinally\b/g,
                /\blastly\b/g,
                /\bmoreover\b/g,
                /\bfurthermore\b/g,
                /\bin addition\b/g,
                /\bplus\b/g,
                /\boh and\b/g,
                /\band\b/g,
                /\,/g,
                /\./g
            ];
            
            let tasks = [text];
            
            // Split by each separator
            separators.forEach(separator => {
                let newTasks = [];
                tasks.forEach(task => {
                    newTasks.push(...task.split(separator));
                });
                tasks = newTasks;
            });
            
            // Clean and filter tasks
            tasks = tasks
                .map(task => task.trim())
                .filter(task => task.length > 2)
                .map(task => {
                    // Capitalize first letter
                    return task.charAt(0).toUpperCase() + task.slice(1);
                })
                .filter(task => {
                    // Remove very short or meaningless tasks
                    const meaninglessWords = ['i', 'me', 'my', 'the', 'a', 'an', 'to', 'do', 'get', 'go', 'have', 'be', 'will', 'want', 'need'];
                    const words = task.toLowerCase().split(' ');
                    return words.length > 1 || !meaninglessWords.includes(words[0]);
                });
            
            // If we couldn't parse individual tasks, treat the whole thing as one task
            if (tasks.length === 0 && transcript.trim().length > 0) {
                tasks = [transcript.trim().charAt(0).toUpperCase() + transcript.trim().slice(1)];
            }
            
            return tasks;
        }

        function updateVoiceUI(state) {
            const animation = document.getElementById('voiceAnimation');
            const status = document.getElementById('voiceStatus');
            const stopBtn = document.getElementById('voiceStopBtn');
            const processBtn = document.getElementById('voiceProcessBtn');
            const transcript = document.getElementById('voiceTranscript');
            const voiceBtn = document.querySelector('.voice-input-btn');
            
            switch(state) {
                case 'ready':
                    animation.classList.remove('recording');
                    voiceBtn.classList.remove('recording');
                    status.innerHTML = '<h3>Tap to start speaking</h3><p>Tell me what you want to get done today.<br>I\'ll create a todo list for you!</p>';
                    stopBtn.style.display = 'none';
                    processBtn.style.display = 'none';
                    transcript.style.display = 'none';
                    break;
                    
                case 'recording':
                    animation.classList.add('recording');
                    voiceBtn.classList.add('recording');
                    status.innerHTML = '<h3>Listening...</h3><p>Speak clearly and tell me all your tasks.<br>I\'m creating your todo list!</p>';
                    stopBtn.style.display = 'block';
                    processBtn.style.display = 'none';
                    transcript.style.display = 'block';
                    break;
                    
                case 'stopped':
                    animation.classList.remove('recording');
                    voiceBtn.classList.remove('recording');
                    status.innerHTML = '<h3>Processing your speech...</h3><p>Review what I heard and create your tasks!</p>';
                    stopBtn.style.display = 'none';
                    processBtn.style.display = 'block';
                    transcript.style.display = 'block';
                    break;
                    
                case 'error':
                    animation.classList.remove('recording');
                    voiceBtn.classList.remove('recording');
                    status.innerHTML = '<h3>Speech recognition error</h3><p>Please try again or check your microphone.</p>';
                    stopBtn.style.display = 'none';
                    processBtn.style.display = 'none';
                    break;
            }
        }

        function updateTranscriptDisplay() {
            const transcriptElement = document.getElementById('transcriptText');
            transcriptElement.textContent = voiceTranscript || 'Listening for your voice...';
        }

        function handleVoiceAnimationClick() {
            if (!isRecording && recognition) {
                // Start recording if not already recording
                recognition.start();
            }
        }

        function showToast(message) {
            // Simple toast notification
            const toast = document.createElement('div');
            toast.style.cssText = `
                position: fixed;
                top: 100px;
                left: 50%;
                transform: translateX(-50%);
                background: linear-gradient(135deg, #51cf66 0%, #37b24d 100%);
                color: white;
                padding: 12px 20px;
                border-radius: 25px;
                font-size: 14px;
                font-weight: 600;
                z-index: 1000;
                animation: slideDown 3s ease-out forwards;
            `;
            
            const style = document.createElement('style');
            style.textContent = `
                @keyframes slideDown {
                    0% { opacity: 0; transform: translateX(-50%) translateY(-20px); }
                    10% { opacity: 1; transform: translateX(-50%) translateY(0); }
                    90% { opacity: 1; transform: translateX(-50%) translateY(0); }
                    100% { opacity: 0; transform: translateX(-50%) translateY(-20px); }
                }
            `;
            document.head.appendChild(style);
            
            toast.textContent = message;
            document.body.appendChild(toast);
            
            setTimeout(() => {
                document.body.removeChild(toast);
                document.head.removeChild(style);
            }, 3000);
        }

        // AI Chat Functions
        let chatMessages = [];
        let isAITyping = false;
        let isChatExpanded = false;

        function handleBottomChatInput() {
            const input = document.getElementById('bottomChatInput');
            const message = input.value.trim();
            
            if (message) {
                // Expand chat if not already expanded
                if (!isChatExpanded) {
                    openChatModal();
                }
                
                // Send the message
                sendMessageFromBottom(message);
                input.value = '';
            }
        }

        function openChatModal() {
            document.getElementById('aiChatModal').classList.add('active');
            isChatExpanded = true;
            
            // Force visibility and proper positioning
            forceInputVisibility();
            
            setTimeout(() => {
                const chatInput = document.getElementById('chatInput');
                const chatContainer = document.querySelector('.chat-input-container');
                
                if (chatInput) {
                    // Apply visibility fixes
                    forceInputVisibility();
                    
                    // Ensure container is properly positioned
                    if (chatContainer) {
                        chatContainer.style.setProperty('position', 'fixed', 'important');
                        chatContainer.style.setProperty('bottom', '0', 'important');
                        chatContainer.style.setProperty('left', '0', 'important');
                        chatContainer.style.setProperty('right', '0', 'important');
                        chatContainer.style.setProperty('z-index', '200', 'important');
                    }
                    
                    // Focus with iOS Safari compatibility
                    chatInput.focus();
                    
                    // Scroll to ensure input is visible on iOS
                    setTimeout(() => {
                        chatInput.scrollIntoView({ 
                            behavior: 'smooth', 
                            block: 'end',
                            inline: 'nearest' 
                        });
                    }, 100);
                }
            }, 300);
        }

        function closeAIChat() {
            document.getElementById('aiChatModal').classList.remove('active');
            document.getElementById('chatInput').value = '';
            document.getElementById('bottomChatInput').value = '';
            isChatExpanded = false;
        }

        function sendMessageFromBottom(message) {
            console.log('=== sendMessageFromBottom called ===');
            console.log('🔵 Message:', message);
            
            // AGGRESSIVE reset - same as main function
            console.log('🔵 AGGRESSIVE CLEAN STATE');
            resetAIState();
            const indicators = document.querySelectorAll('.typing-indicator');
            indicators.forEach(i => i.remove());
            console.log('🔵 State cleaned, isAITyping now:', isAITyping);
            
            // Add user message
            addMessageToChat('user', message);
            
            // Extract tasks
            const detectedTasks = extractTasksFromMessage(message);
            console.log('🔵 Bottom detected tasks:', detectedTasks);
            
            // Start typing
            isAITyping = true;
            window.aiTypingStartTime = Date.now(); // Track when typing started
            showAITyping();
            
            // GUARANTEED response in 2 seconds
            const guaranteedTimer = setTimeout(() => {
                try {
                    console.log('🔵 BOTTOM GUARANTEED RESPONSE TRIGGERED');
                    
                    // Force response
                    resetAIState();
                    console.log('🔵 Forced isAITyping to false');
                    
                    const response = generateQuickResponse(message, detectedTasks);
                    console.log('🔵 Bottom generated response:', response);
                    
                    if (response) {
                        addMessageToChat('ai', response);
                    } else {
                        addMessageToChat('ai', "I'm here to help! What would you like to work on?");
                    }
                    
                    if (detectedTasks && detectedTasks.length > 0) {
                        setTimeout(() => {
                            showDetectedTasks(detectedTasks);
                        }, 500);
                    }
                    
                    // Extra safety cleanup
                    setTimeout(() => {
                        console.log('🔵 SAFETY CHECK - Final cleanup');
                        resetAIState();
                        console.log('🔵 Final isAITyping state:', isAITyping);
                    }, 1000);
                    
                } catch (error) {
                    console.error('🔵 Error in bottom guaranteed response:', error);
                    isAITyping = false;
                    hideAITyping();
                    addMessageToChat('ai', "I'm here to help! What would you like to work on today?");
                }
            }, 2000);
            
            // Try real AI
            generateAIResponseWithRetry(message)
                .then(aiResponse => {
                    if (isAITyping) {
                        console.log('🔵 Bottom using real AI response');
                        clearTimeout(guaranteedTimer);
                        isAITyping = false;
                        hideAITyping();
                        addMessageToChat('ai', aiResponse);
                        
                        if (detectedTasks && detectedTasks.length > 0) {
                            setTimeout(() => {
                                showDetectedTasks(detectedTasks);
                            }, 500);
                        }
                        
                        // Extra safety cleanup
                        setTimeout(() => {
                            isAITyping = false;
                            hideAITyping();
                        }, 1000);
                    } else {
                        console.log('🔵 Bottom AI came too late');
                    }
                })
                .catch(error => {
                    console.log('🔵 Bottom AI failed:', error.message);
                });
        }

        function sendMessage() {
            const input = document.getElementById('chatInput');
            const message = input.value.trim();
            
            console.log('=== sendMessage called ===');
            console.log('Message:', message);
            console.log('isAITyping before:', isAITyping);
            
            // AGGRESSIVE reset - always start clean
            console.log('🧹 AGGRESSIVE CLEAN STATE');
            resetAIState();
            const indicators = document.querySelectorAll('.typing-indicator');
            indicators.forEach(i => i.remove());
            console.log('🧹 State cleaned, isAITyping now:', isAITyping);
            
            if (message) {
                console.log('✅ Processing message...');
                
                // Clear input immediately
                input.value = '';
                
                // Add user message to chat
                addMessageToChat('user', message);
                
                // Extract tasks FIRST
                const detectedTasks = extractTasksFromMessage(message);
                console.log('📋 Detected tasks:', detectedTasks);
                
                // Start typing indicator
                isAITyping = true;
                window.aiTypingStartTime = Date.now(); // Track when typing started
                showAITyping();
                console.log('👤 AI typing started, isAITyping:', isAITyping);
                
                // GUARANTEED response in 2 seconds - faster
                const guaranteedTimer = setTimeout(() => {
                    try {
                        console.log('⚡ GUARANTEED RESPONSE TRIGGERED');
                        console.log('⚡ Current isAITyping state:', isAITyping);
                        
                        // Force response no matter what
                        resetAIState();
                        console.log('⚡ Forced isAITyping to false');
                        
                        // Generate response
                        const response = generateQuickResponse(message, detectedTasks);
                        console.log('⚡ Generated response:', response);
                        
                        if (response) {
                            addMessageToChat('ai', response);
                        } else {
                            addMessageToChat('ai', "I'm here to help! What would you like to work on?");
                        }
                        
                        // Show tasks
                        if (detectedTasks && detectedTasks.length > 0) {
                            console.log('⚡ Showing tasks:', detectedTasks);
                            setTimeout(() => {
                                showDetectedTasks(detectedTasks);
                            }, 500);
                        }
                        
                        // Extra safety - ensure state is clean
                        setTimeout(() => {
                            console.log('🔒 SAFETY CHECK - Final cleanup');
                            resetAIState();
                            console.log('🔒 Final isAITyping state:', isAITyping);
                        }, 1000);
                        
                    } catch (error) {
                        console.error('⚡ Error in guaranteed response:', error);
                        isAITyping = false;
                        hideAITyping();
                        addMessageToChat('ai', "I'm here to help! What would you like to work on today?");
                    }
                }, 2000); // 2 second guaranteed response (faster)
                
                // Try real AI (but don't depend on it)
                generateAIResponseWithRetry(message)
                    .then(aiResponse => {
                        console.log('🤖 Real AI responded:', aiResponse);
                        // Only use if we haven't already responded
                        if (isAITyping) {
                            console.log('🤖 Using real AI response');
                            clearTimeout(guaranteedTimer);
                            isAITyping = false;
                            hideAITyping();
                            addMessageToChat('ai', aiResponse);
                            
                            if (detectedTasks && detectedTasks.length > 0) {
                                setTimeout(() => {
                                    showDetectedTasks(detectedTasks);
                                }, 500);
                            }
                            
                            // Extra safety cleanup
                            setTimeout(() => {
                                isAITyping = false;
                                hideAITyping();
                            }, 1000);
                        } else {
                            console.log('🤖 AI came too late, already responded');
                        }
                    })
                    .catch(error => {
                        console.log('🤖 Real AI failed:', error.message);
                        // Guaranteed response will handle this
                    });
                    
            } else {
                console.log('❌ No message to send');
            }
        }
        
        // Helper function to properly reset AI state
        function resetAIState() {
            isAITyping = false;
            window.aiTypingStartTime = null;
            hideAITyping();
        }
        
        // Quick response generator for fallback
        function generateQuickResponse(message, detectedTasks) {
            console.log('📝 Generating quick response for:', message);
            console.log('📝 Detected tasks:', detectedTasks);
            
            try {
                const lowerMessage = message.toLowerCase();
                
                if (detectedTasks && detectedTasks.length > 0) {
                    const taskList = detectedTasks.join(' and ');
                    const response = `Great! I can see you want to work on: ${taskList}. I'll help you add these to your planner. When are you thinking of tackling these tasks?`;
                    console.log('📝 Using task-based response:', response);
                    return response;
                }
            } catch (error) {
                console.error('📝 Error in generateQuickResponse:', error);
            }
            
            // Context-aware responses for common cases
            if (lowerMessage.includes('call') && lowerMessage.includes('mom')) {
                return "📞 Calling your mom is such a thoughtful idea! Family connections are so important. What's a good time when you both are usually free to chat?";
            } else if (lowerMessage.includes('read') && lowerMessage.includes('book')) {
                return "📚 Reading is an excellent goal! What type of book are you in the mood for? Setting aside some dedicated reading time will help make it happen.";
            } else if (lowerMessage.includes('gym') || lowerMessage.includes('workout') || lowerMessage.includes('exercise')) {
                return "💪 That's awesome! Exercise is such an important habit. What time of day works best for your workouts?";
            } else if (lowerMessage.includes('walk') && lowerMessage.includes('dog')) {
                return "🐕 Your dog will love that! Regular walks are great exercise for both of you. How long do you usually walk for?";
            } else if (lowerMessage.includes('clean')) {
                return "🧹 Cleaning can feel so satisfying once it's done! Which area are you planning to tackle first?";
            } else if (lowerMessage.includes('cook') || lowerMessage.includes('food') || lowerMessage.includes('eat')) {
                return "🍳 Cooking is such a great skill! Are you planning to try a new recipe or make a favorite dish?";
            } else if (lowerMessage.includes('work') || lowerMessage.includes('study')) {
                return "📝 Staying productive is important! What's the main thing you want to focus on getting done?";
            } else {
                const response = `I hear you want to work on something important! While I'm having a moment of connection trouble, I'm still here to help you organize your day. What's the most important thing you'd like to focus on?`;
                console.log('📝 Using fallback response:', response);
                return response;
            }
            
            // Emergency fallback if everything else fails
            return "I'm here to help! What would you like to work on today?";
        }
        
        // Add a simple test function
        window.testSimpleMessage = function() {
            console.log('=== Testing simple message ===');
            const message = "I also want to read a book and call my mother";
            addMessageToChat('user', message);
            
            const detectedTasks = extractTasksFromMessage(message);
            console.log('Tasks detected:', detectedTasks);
            
            setTimeout(() => {
                addMessageToChat('ai', 'This is a simple test response. Tasks detected: ' + detectedTasks.length);
                if (detectedTasks.length > 0) {
                    setTimeout(() => {
                        showDetectedTasks(detectedTasks);
                    }, 500);
                }
            }, 1000);
        }
        
        // Debug function to check task container state
        window.debugTaskContainer = function() {
            console.log('=== DEBUG TASK CONTAINER ===');
            const container = document.getElementById('detectedTasksContainer');
            const tasksList = document.getElementById('detectedTasksList');
            
            console.log('Container element:', container);
            console.log('Container display:', container ? container.style.display : 'not found');
            console.log('Container visibility:', container ? container.style.visibility : 'not found');
            console.log('Container innerHTML:', container ? container.innerHTML : 'not found');
            
            console.log('TasksList element:', tasksList);
            console.log('TasksList children count:', tasksList ? tasksList.children.length : 'not found');
            console.log('TasksList innerHTML:', tasksList ? tasksList.innerHTML : 'not found');
            
            if (tasksList && tasksList.children.length > 0) {
                console.log('Task items:');
                Array.from(tasksList.children).forEach((item, index) => {
                    console.log(`Task ${index}:`, item.textContent, 'Visible:', item.offsetHeight > 0);
                });
            }
        }
        
        // Force show task detection for testing
        window.forceShowTasks = function() {
            console.log('=== FORCE SHOW TASKS ===');
            const testTasks = ['Go to the gym', 'Read a book'];
            showDetectedTasks(testTasks);
        }

        function addMessageToChat(sender, message) {
            const messagesContainer = document.getElementById('chatMessages');
            const messageDiv = document.createElement('div');
            messageDiv.className = `${sender}-message`;
            
            if (sender === 'ai') {
                messageDiv.innerHTML = `
                    <div class="message-bubble ai-bubble">
                        <i class="fas fa-robot"></i>
                        <span>${message}</span>
                    </div>
                `;
            } else {
                messageDiv.innerHTML = `
                    <div class="message-bubble user-bubble">
                        <span>${message}</span>
                    </div>
                `;
            }
            
            messagesContainer.appendChild(messageDiv);
            
            // Smooth scroll to bottom for new messages
            setTimeout(() => {
                messagesContainer.scrollTo({
                    top: messagesContainer.scrollHeight,
                    behavior: 'smooth'
                });
            }, 50);
            
            // Store message
            chatMessages.push({ sender, message, timestamp: new Date() });
            
            // Show create tasks button after meaningful conversation
            if (chatMessages.length >= 4) { // After at least 2 exchanges
                document.getElementById('createTasksBtn').style.display = 'flex';
            }
        }

        function showAITyping() {
            // First, make sure any existing typing indicator is removed
            hideAITyping();
            
            isAITyping = true;
            console.log('AI typing started');
            
            const messagesContainer = document.getElementById('chatMessages');
            const typingDiv = document.createElement('div');
            typingDiv.className = 'ai-message typing-indicator';
            typingDiv.id = 'typingIndicator';
            typingDiv.innerHTML = `
                <div class="message-bubble ai-bubble">
                    <i class="fas fa-robot"></i>
                    <span>AI is thinking</span>
                    <div class="typing-dots">
                        <span></span>
                        <span></span>
                        <span></span>
                    </div>
                </div>
            `;
            messagesContainer.appendChild(typingDiv);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }

        function hideAITyping() {
            isAITyping = false;
            console.log('AI typing stopped, isAITyping now:', isAITyping);
            
            // Remove all typing indicators to prevent duplicates
            const typingIndicators = document.querySelectorAll('.typing-indicator');
            typingIndicators.forEach(indicator => indicator.remove());
            
            // Force reset the flag to ensure future messages can be sent
            setTimeout(() => {
                isAITyping = false;
            }, 100);
        }

        // Gemini API Configuration
        // TO USE REAL AI: Replace 'YOUR_GEMINI_API_KEY_HERE' with your actual Gemini API key
        // Get your free API key at: https://aistudio.google.com/app/apikey
        const GEMINI_API_KEY = 'AIzaSyAHvMe7YKXJChAFA3FBQGIaYEcN8DHuoLA';
        const GEMINI_API_URL = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent';

        // Firebase Configuration
        // TO USE FIREBASE: Replace with your Firebase config from Firebase Console
        const firebaseConfig = {
            apiKey: "demo-api-key", // Replace with your Firebase API key
            authDomain: "memaster-demo.firebaseapp.com", // Replace with your domain
            projectId: "memaster-demo", // Replace with your project ID
            storageBucket: "memaster-demo.appspot.com",
            messagingSenderId: "123456789",
            appId: "demo-app-id"
        };

        // Initialize Firebase
        let db = null;
        let isFirebaseEnabled = false;
        let isOnline = navigator.onLine;
        let syncQueue = [];

        try {
            // Only initialize if Firebase is properly configured
            if (firebaseConfig.apiKey !== "demo-api-key") {
                firebase.initializeApp(firebaseConfig);
                db = firebase.firestore();
                
                // Enable offline persistence
                db.enablePersistence({ synchronizeTabs: true })
                    .then(() => {
                        console.log('🔥 Firebase offline persistence enabled');
                        isFirebaseEnabled = true;
                        updateSyncStatus();
                    })
                    .catch((error) => {
                        console.warn('Firebase persistence failed:', error);
                        // Still use Firebase but without persistence
                        isFirebaseEnabled = true;
                        updateSyncStatus();
                    });
            } else {
                console.log('🔥 Firebase demo mode - using localStorage fallback');
                updateSyncStatus();
            }
        } catch (error) {
            console.error('Firebase initialization failed:', error);
            console.log('📦 Falling back to localStorage');
            updateSyncStatus();
        }

        // Sync Status Management
        function updateSyncStatus() {
            const statusEl = document.getElementById('syncStatus');
            const iconEl = document.getElementById('syncIcon');
            const textEl = document.getElementById('syncText');
            
            if (!statusEl) return; // Not loaded yet
            
            statusEl.className = 'sync-status';
            iconEl.className = 'fas sync-icon';
            
            if (!isOnline) {
                statusEl.classList.add('offline');
                iconEl.classList.add('fa-wifi-slash');
                textEl.textContent = 'Offline';
            } else if (isFirebaseEnabled) {
                if (syncQueue.length > 0) {
                    statusEl.classList.add('syncing');
                    iconEl.classList.add('fa-sync', 'spinning');
                    textEl.textContent = 'Syncing';
                } else {
                    statusEl.classList.add('online');
                    iconEl.classList.add('fa-cloud');
                    textEl.textContent = 'Synced';
                }
            } else {
                statusEl.classList.add('offline');
                iconEl.classList.add('fa-hdd');
                textEl.textContent = 'Local';
            }
        }

        // Network Status Monitoring
        window.addEventListener('online', () => {
            isOnline = true;
            console.log('📡 Back online - attempting sync');
            updateSyncStatus();
            if (isFirebaseEnabled) {
                processSyncQueue();
            }
        });

        window.addEventListener('offline', () => {
            isOnline = false;
            console.log('📡 Gone offline - using local storage');
            updateSyncStatus();
        });

        // Data Layer - handles both Firebase and localStorage
        const DataLayer = {
            // Save todos
            async saveTodos(todosArray) {
                console.log('💾 Saving todos:', todosArray.length, 'items');
                
                if (isFirebaseEnabled && isOnline) {
                    try {
                        // Save to Firebase
                        const batch = db.batch();
                        const todosRef = db.collection('todos');
                        
                        // Clear existing todos first (simple approach)
                        const existingTodos = await todosRef.get();
                        existingTodos.forEach(doc => {
                            batch.delete(doc.ref);
                        });
                        
                        // Add new todos
                        todosArray.forEach(todo => {
                            const docRef = todosRef.doc(todo.id);
                            batch.set(docRef, {
                                ...todo,
                                updatedAt: firebase.firestore.FieldValue.serverTimestamp()
                            });
                        });
                        
                        await batch.commit();
                        console.log('✅ Todos saved to Firebase');
                        updateSyncStatus();
                        return true;
                    } catch (error) {
                        console.error('❌ Firebase save failed:', error);
                        // Fall back to localStorage
                        localStorage.setItem('memaster_todos', JSON.stringify(todosArray));
                        return false;
                    }
                } else {
                    // Save to localStorage
                    localStorage.setItem('memaster_todos', JSON.stringify(todosArray));
                    console.log('💾 Todos saved to localStorage');
                    return true;
                }
            },

            // Load todos
            async loadTodos() {
                console.log('📂 Loading todos...');
                
                if (isFirebaseEnabled) {
                    try {
                        const todosRef = db.collection('todos');
                        const snapshot = await todosRef.orderBy('createdAt', 'desc').get();
                        
                        const firebaseTodos = [];
                        snapshot.forEach(doc => {
                            const data = doc.data();
                            // Convert Firebase timestamps to ISO strings
                            if (data.createdAt && data.createdAt.toDate) {
                                data.createdAt = data.createdAt.toDate().toISOString();
                            }
                            if (data.updatedAt && data.updatedAt.toDate) {
                                data.updatedAt = data.updatedAt.toDate().toISOString();
                            }
                            firebaseTodos.push(data);
                        });
                        
                        console.log('✅ Loaded', firebaseTodos.length, 'todos from Firebase');
                        
                        // Also save to localStorage as backup
                        localStorage.setItem('memaster_todos', JSON.stringify(firebaseTodos));
                        updateSyncStatus();
                        return firebaseTodos;
                    } catch (error) {
                        console.error('❌ Firebase load failed:', error);
                        // Fall back to localStorage
                        const localTodos = JSON.parse(localStorage.getItem('memaster_todos')) || [];
                        console.log('📦 Loaded', localTodos.length, 'todos from localStorage');
                        return localTodos;
                    }
                } else {
                    // Load from localStorage
                    const localTodos = JSON.parse(localStorage.getItem('memaster_todos')) || [];
                    console.log('📦 Loaded', localTodos.length, 'todos from localStorage');
                    return localTodos;
                }
            },

            // Queue sync for offline operations
            queueSync(operation, data) {
                syncQueue.push({ operation, data, timestamp: Date.now() });
                console.log('⏳ Queued sync operation:', operation);
                updateSyncStatus();
            }
        };

        // Process sync queue when back online
        async function processSyncQueue() {
            if (!isFirebaseEnabled || !isOnline || syncQueue.length === 0) return;
            
            console.log('🔄 Processing sync queue:', syncQueue.length, 'items');
            updateSyncStatus();
            
            try {
                // For simplicity, just reload and save current state
                await DataLayer.saveTodos(todos);
                syncQueue = [];
                console.log('✅ Sync queue processed');
            } catch (error) {
                console.error('❌ Sync queue processing failed:', error);
            }
            
            updateSyncStatus();
        }

        // Add retry logic for API calls
        async function generateAIResponseWithRetry(userMessage, retryCount = 0) {
            const maxRetries = 2;
            
            try {
                console.log(`API call attempt ${retryCount + 1}/${maxRetries + 1}`);
                const response = await generateAIResponse(userMessage);
                return response;
            } catch (error) {
                console.log(`API call attempt ${retryCount + 1} failed:`, error.message);
                
                if (retryCount < maxRetries) {
                    // Wait a bit before retrying (exponential backoff)
                    const delay = Math.pow(2, retryCount) * 1000; // 1s, 2s, 4s...
                    console.log(`Retrying in ${delay}ms...`);
                    await new Promise(resolve => setTimeout(resolve, delay));
                    return generateAIResponseWithRetry(userMessage, retryCount + 1);
                } else {
                    // All retries exhausted, throw the error
                    throw error;
                }
            }
        }

        async function generateAIResponse(userMessage) {
            console.log('=== generateAIResponse called ===');
            console.log('User message:', userMessage);
            console.log('API Key configured:', GEMINI_API_KEY ? 'YES' : 'NO');
            console.log('API Key length:', GEMINI_API_KEY ? GEMINI_API_KEY.length : 0);
            console.log('Timestamp:', new Date().toISOString());
            
            // Check if API key is configured
            if (!GEMINI_API_KEY || GEMINI_API_KEY === 'YOUR_GEMINI_API_KEY_HERE') {
                console.warn('Gemini API key not configured');
                return "🤖 **Real AI not configured yet!** To enable intelligent responses, add your Gemini API key at the top of this file. Get your free key at: https://aistudio.google.com/app/apikey\n\nFor now, I can still help with task detection! Try saying: 'I want to go to the gym and read a book'";
            }
            
            try {
                console.log('Sending request to:', GEMINI_API_URL);
                console.log('Request payload preview:', {
                    message: userMessage.substring(0, 50),
                    hasApiKey: !!GEMINI_API_KEY
                });
                
                const requestBody = {
                    contents: [{
                        parts: [{
                            text: `You are a helpful AI assistant for a task planning app called MeMaster. Your role is to help users organize their daily tasks and goals in a friendly, encouraging way.

User's message: "${userMessage}"

Please respond in a conversational, helpful manner about their tasks or goals. Keep responses concise (2-3 sentences) and focus on productivity, planning, and encouragement. If they mention specific activities, acknowledge them and ask follow-up questions to help them plan better.`
                        }]
                    }]
                };
                
                const response = await fetch(GEMINI_API_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-goog-api-key': GEMINI_API_KEY
                    },
                    body: JSON.stringify(requestBody)
                });

                console.log('Response status:', response.status);
                console.log('Response ok:', response.ok);
                console.log('Response headers:', Object.fromEntries(response.headers.entries()));

                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('API Error Response:', errorText);
                    
                    if (response.status === 403) {
                        throw new Error('Invalid API key - please check your Gemini API key');
                    } else if (response.status === 429) {
                        throw new Error('Rate limit exceeded - too many requests');
                    } else if (response.status === 400) {
                        throw new Error('Bad request - check API parameters');
                    }
                    throw new Error(`API request failed: ${response.status} - ${errorText}`);
                }

                const data = await response.json();
                console.log('Full API response:', data);
                
                const aiResponse = data.candidates?.[0]?.content?.parts?.[0]?.text || "I'm here to help you plan your day! What would you like to work on?";
                
                console.log('Extracted AI response:', aiResponse);
                return aiResponse;
                
            } catch (error) {
                console.error('Full Gemini API error:', error);
                console.error('Error type:', typeof error);
                console.error('Error message:', error.message);
                console.error('Error stack:', error.stack);
                
                // Specific error messages for common issues
                if (error.message.includes('Invalid API key')) {
                    return "❌ **API Key Error:** Your Gemini API key appears to be invalid. Please check it and try again. Get a new key at: https://aistudio.google.com/app/apikey";
                }
                
                if (error.message.includes('Rate limit exceeded') || error.message.includes('429')) {
                    return "⏱️ **Rate Limited:** The AI service is getting too many requests. Please wait 30 seconds and try again, or the task detection will still work!";
                }
                
                if (error.message.includes('403')) {
                    return "❌ **Access Denied:** Please check your Gemini API key permissions. Make sure it's correctly configured.";
                }
                
                if (error.message.includes('Failed to fetch') || error.message.includes('network')) {
                    return "🌐 **Network Error:** Can't connect to the AI service. Please check your internet connection and try again.";
                }
                
                // Fallback to simple AI responses
                console.log('Using fallback AI response due to API error');
                
                // Simple rule-based responses for common cases
                const lowerMessage = userMessage.toLowerCase();
                
                if (lowerMessage.includes('read') && lowerMessage.includes('book')) {
                    return "📚 Reading is a great goal! What type of book are you thinking of reading? Setting aside dedicated reading time will help you actually get it done!";
                } else if (lowerMessage.includes('gym') || lowerMessage.includes('exercise') || lowerMessage.includes('workout')) {
                    return "💪 Excellent! Going to the gym is such an important habit. What time works best for your workout? Planning it out will help make sure it happens!";
                } else if (lowerMessage.includes('walk') && lowerMessage.includes('dog')) {
                    return "🐕 Your dog will love that! Walking is great exercise for both of you. What time do you usually take your walks?";
                } else if (lowerMessage.includes('clean')) {
                    return "🧹 Cleaning can be so satisfying once it's done! Breaking it into smaller tasks makes it feel less overwhelming. What area are you planning to tackle?";
                } else if (lowerMessage.includes('call') && lowerMessage.includes('mom')) {
                    return "📞 That's so thoughtful! Family connections are important. Is there a good time when you both are usually free to chat?";
                } else {
                    return `I hear you want to work on: "${userMessage}". That sounds like a great goal! When are you planning to tackle this? The task detection should still work even though the AI service is having issues.`;
                }
            }
        }



        async function createTasksFromChat() {
            // Extract potential tasks from the conversation
            const userMessages = chatMessages.filter(msg => msg.sender === 'user');
            const extractedTasks = [];
            
            userMessages.forEach(msg => {
                const tasks = extractTasksFromMessage(msg.message);
                extractedTasks.push(...tasks);
            });
            
            if (extractedTasks.length > 0) {
                // Add tasks to the todo list
                extractedTasks.forEach(taskText => {
                    const todo = {
                        id: Date.now().toString() + Math.random().toString(36).substr(2, 9),
                        text: taskText.trim(),
                        completed: false,
                        date: selectedDate.toISOString().split('T')[0],
                        createdAt: new Date().toISOString()
                    };
                    todos.push(todo);
                });

                // Save using DataLayer
                try {
                    await DataLayer.saveTodos(todos);
                    console.log('✅ Chat tasks created and saved');
                } catch (error) {
                    console.error('❌ Failed to save chat tasks:', error);
                    if (!isOnline && isFirebaseEnabled) {
                        extractedTasks.forEach(taskText => {
                            DataLayer.queueSync('add', {
                                id: Date.now().toString() + Math.random().toString(36).substr(2, 9),
                                text: taskText.trim(),
                                completed: false,
                                date: selectedDate.toISOString().split('T')[0],
                                createdAt: new Date().toISOString()
                            });
                        });
                    }
                }
                
                // Close chat and refresh UI
                closeAIChat();
                renderTodos();
                updateStats();
                
                // Show success message
                showToast(`Created ${extractedTasks.length} tasks from your conversation!`);
                
                // Add AI confirmation message
                addMessageToChat('ai', `Perfect! I've created ${extractedTasks.length} tasks for you based on our conversation. Check your Today view to see them!`);
            } else {
                // Add AI message asking for more specific information
                addMessageToChat('ai', "I'd love to help create tasks, but I need a bit more specific information. Can you tell me exactly what you'd like to accomplish today? For example: 'I need to clean my room' or 'I want to call my mom'.");
            }
        }

        function extractTasksFromMessage(message) {
            console.log('=== ENHANCED extractTasksFromMessage called ===');
            console.log('Original message:', message);
            const tasks = [];
            const text = message.toLowerCase().trim();
            console.log('Lowercase text:', text);
            
            // STEP 1: Split message by multiple delimiters to catch all parts
            // Split by: periods followed by connectors like "oh and", "also", "then", etc.
            const segments = text.split(/(?:\.\s*(?:oh\s+and|and\s+also|also|then|and\s+then)|,\s*(?:and|also|then))/).filter(s => s.trim().length > 0);
            console.log('📝 Split into segments:', segments);
            
            // If no splits found, try simpler split on periods
            if (segments.length === 1) {
                const periodSplit = text.split(/\.\s*/).filter(s => s.trim().length > 0);
                if (periodSplit.length > 1) {
                    segments.splice(0, 1, ...periodSplit);
                    console.log('📝 Using period split instead:', segments);
                }
            }
            
            // STEP 1.5: If still only one segment, try splitting by commas
            if (segments.length === 1) {
                const commaSplit = text.split(/,\s*(?:and\s+)?/).filter(s => s.trim().length > 0);
                if (commaSplit.length > 1) {
                    segments.splice(0, 1, ...commaSplit);
                    console.log('📝 Using comma split instead:', segments);
                }
            }
            
            // STEP 1.6: Special handling for the specific pattern "Go for a run, walk my dog, and read a book"
            if (segments.length === 1 && text.includes('go for a run') && text.includes('walk my dog') && text.includes('read a book')) {
                console.log('📝 Detected specific 4-task pattern, forcing split');
                const forcedSegments = [];
                
                // Extract "swim today" from first part
                if (text.includes('swim today')) {
                    forcedSegments.push('swim today');
                }
                
                // Extract comma-separated tasks
                const commaParts = text.split(/,\s*(?:and\s+)?/).filter(s => s.trim().length > 0);
                commaParts.forEach(part => {
                    if (part.includes('go for a run') || part.includes('walk my dog') || part.includes('read a book')) {
                        forcedSegments.push(part.trim());
                    }
                });
                
                if (forcedSegments.length > 1) {
                    segments.splice(0, 1, ...forcedSegments);
                    console.log('📝 Forced split result:', segments);
                }
            }
            
            // STEP 1.7: More aggressive comma splitting for any comma-separated list
            if (segments.length === 1 && text.includes(',')) {
                console.log('📝 Detected comma-separated list, aggressive splitting');
                
                // Handle "I want to X, Y, Z, and W" pattern
                if (text.startsWith('i want to ')) {
                    const withoutPrefix = text.replace(/^i\s+want\s+to\s+/, '');
                    console.log('📝 Without prefix:', withoutPrefix);
                    
                    // Split by comma and "and"
                    const commaSplit = withoutPrefix.split(/,\s*(?:and\s+)?/).filter(s => s.trim().length > 0);
                    if (commaSplit.length > 1) {
                        segments.splice(0, 1, ...commaSplit);
                        console.log('📝 Comma split with prefix removal:', segments);
                    }
                } else {
                    // Regular comma splitting
                    const commaSplit = text.split(/,\s*(?:and\s+)?/).filter(s => s.trim().length > 0);
                    if (commaSplit.length > 1) {
                        segments.splice(0, 1, ...commaSplit);
                        console.log('📝 Regular comma split result:', segments);
                    }
                }
            }
            
            // STEP 1.8: Handle continuous task lists without punctuation
            if (segments.length === 1 && text.includes(' and ') && !text.includes(',') && !text.includes('.')) {
                console.log('📝 Detected continuous task list, splitting by "and"');
                const andSplit = text.split(/\s+and\s+/).filter(s => s.trim().length > 0);
                if (andSplit.length > 1) {
                    segments.splice(0, 1, ...andSplit);
                    console.log('📝 Continuous "and" split result:', segments);
                }
            }
            
            // STEP 1.9: Handle concatenated tasks without separators
            if (segments.length === 1 && !text.includes(',') && !text.includes('.') && !text.includes(' and ')) {
                console.log('📝 Detected concatenated tasks, trying smart extraction');
                
                // Look for known task patterns in the text
                const knownTasks = [
                    'go for a run', 'read a book', 'walk my dog', 'clean my room',
                    'swim', 'hike', 'exercise', 'workout', 'call my mom', 'go to the gym'
                ];
                
                const foundTasks = [];
                let remainingText = text;
                
                knownTasks.forEach(task => {
                    if (remainingText.includes(task)) {
                        foundTasks.push(task);
                        remainingText = remainingText.replace(task, '').trim();
                        console.log(`📝 Found task: ${task}, remaining: "${remainingText}"`);
                    }
                });
                
                if (foundTasks.length > 1) {
                    segments.splice(0, 1, ...foundTasks);
                    console.log('📝 Smart extraction result:', segments);
                }
            }
            
            // STEP 1.10: Handle "I want to X Y Z and W" pattern specifically
            if (segments.length === 1 && text.startsWith('i want to ') && text.includes(' and ')) {
                console.log('📝 Detected "I want to" pattern with "and", extracting tasks');
                
                // Remove "I want to" prefix
                const withoutPrefix = text.replace(/^i\s+want\s+to\s+/, '');
                console.log('📝 Without prefix:', withoutPrefix);
                
                // Split by "and"
                const andParts = withoutPrefix.split(/\s+and\s+/);
                console.log('📝 And parts:', andParts);
                
                if (andParts.length > 1) {
                    segments.splice(0, 1, ...andParts);
                    console.log('📝 "I want to" split result:', segments);
                }
            }
            
            segments.forEach((segment, index) => {
                console.log(`📝 Processing segment ${index + 1}:`, segment.trim());
                
                // For segments with "and", try to split further and process each part
                const segmentText = segment.trim();
                if (segmentText.includes(' and ') && index === 0) {
                    // First segment might have multiple tasks connected by "and"
                    console.log('📝 First segment contains "and", processing both parts');
                    const andParts = segmentText.split(' and ');
                    andParts.forEach((part, partIndex) => {
                        const partTasks = extractTasksFromSegment(part.trim());
                        partTasks.forEach(task => {
                            if (task && !tasks.some(existingTask => 
                                existingTask.toLowerCase().includes(task.toLowerCase()) || 
                                task.toLowerCase().includes(existingTask.toLowerCase())
                            )) {
                                tasks.push(task);
                                console.log(`📝 Added task from part ${partIndex + 1}:`, task);
                            }
                        });
                    });
                } else if (segmentText.includes(',') && segmentText.includes(' and ')) {
                    // Handle comma-separated lists with "and" at the end
                    console.log('📝 Segment contains comma list with "and", processing each part');
                    const commaParts = segmentText.split(/,\s*(?:and\s+)?/).filter(s => s.trim().length > 0);
                    commaParts.forEach((part, partIndex) => {
                        const partTasks = extractTasksFromSegment(part.trim());
                        partTasks.forEach(task => {
                            if (task && !tasks.some(existingTask => 
                                existingTask.toLowerCase().includes(task.toLowerCase()) || 
                                task.toLowerCase().includes(existingTask.toLowerCase())
                            )) {
                                tasks.push(task);
                                console.log(`📝 Added task from comma part ${partIndex + 1}:`, task);
                            }
                        });
                    });
                } else if (segmentText.includes(' and ')) {
                    // Any segment with "and" should be split
                    console.log('📝 Segment contains "and", processing both parts');
                    const andParts = segmentText.split(' and ');
                    andParts.forEach((part, partIndex) => {
                        const partTasks = extractTasksFromSegment(part.trim());
                        partTasks.forEach(task => {
                            if (task && !tasks.some(existingTask => 
                                existingTask.toLowerCase().includes(task.toLowerCase()) || 
                                task.toLowerCase().includes(existingTask.toLowerCase())
                            )) {
                                tasks.push(task);
                                console.log(`📝 Added task from "and" part ${partIndex + 1}:`, task);
                            }
                        });
                    });
                } else {
                    // Process segment normally
                    const segmentTasks = extractTasksFromSegment(segmentText);
                    segmentTasks.forEach(task => {
                        if (task && !tasks.some(existingTask => 
                            existingTask.toLowerCase().includes(task.toLowerCase()) || 
                            task.toLowerCase().includes(existingTask.toLowerCase())
                        )) {
                            tasks.push(task);
                            console.log('📝 Added task:', task);
                        }
                    });
                }
            });
            
            console.log('📝 Final extracted tasks:', tasks);
            return tasks;
        }
        
        // Helper function to extract tasks from a single segment
        function extractTasksFromSegment(segment) {
            console.log('🔍 Processing segment:', segment);
            const tasks = [];
            const text = segment.toLowerCase().trim();
            
            // Common task keywords and their normalized forms
            const taskMappings = {
                'clean my room': 'Clean my room',
                'cleand my room': 'Clean my room', // Handle typos
                'clean room': 'Clean my room',
                'tidy my room': 'Clean my room',
                'walk my dog': 'Walk my dog',
                'walk the dog': 'Walk my dog',
                'walk dog': 'Walk my dog',
                'feed my dog': 'Feed my dog',
                'feed the dog': 'Feed my dog',
                'go for a run': 'Go for a run',
                'go running': 'Go for a run',
                'run': 'Go for a run',
                'swim': 'Swim',
                'swimming': 'Swim',
                'go swimming': 'Swim',
                'go for a hike': 'Go for a hike',
                'go hiking': 'Go for a hike',
                'hike': 'Go for a hike',
                'hiking': 'Go for a hike',
                'go to the gym': 'Go to the gym',
                'go to gym': 'Go to the gym',
                'gym': 'Go to the gym',
                'workout': 'Workout',
                'exercise': 'Exercise',
                'read a book': 'Read a book',
                'read book': 'Read a book',
                'call my mom': 'Call my mom',
                'call mom': 'Call my mom',
                'play video games': 'Play video games',
                'play games': 'Play video games',
                'go to the movies': 'Go to the movies',
                'see a movie': 'Go to the movies',
                'watch a movie': 'Watch a movie',
                'eat dinner': 'Eat dinner',
                'have dinner': 'Eat dinner',
                'cook dinner': 'Cook dinner',
                'make dinner': 'Cook dinner',
                'eat lunch': 'Eat lunch',
                'have lunch': 'Eat lunch',
                'eat breakfast': 'Eat breakfast',
                'have breakfast': 'Eat breakfast',
                'cook': 'Cook',
                'make food': 'Cook',
                'prepare food': 'Cook'
            };
            
            // STEP 1: Try to match known task patterns directly
            for (const [pattern, normalizedTask] of Object.entries(taskMappings)) {
                if (text.includes(pattern)) {
                    tasks.push(normalizedTask);
                    console.log('🔍 Direct match found:', normalizedTask);
                    // Don't return early - continue checking for more tasks in the same segment
                }
            }
            
            // If we found direct matches, return them (but only if we found some)
            if (tasks.length > 0) {
                console.log('🔍 Returning direct matches:', tasks);
                return tasks;
            }
            
            // STEP 1.5: Handle "oh and X" patterns specifically
            if (text.startsWith('oh and ')) {
                const afterOhAnd = text.substring(7).trim(); // Remove "oh and "
                console.log('🔍 Processing "oh and" pattern:', afterOhAnd);
                
                // Check if it matches any known tasks
                for (const [pattern, normalizedTask] of Object.entries(taskMappings)) {
                    if (afterOhAnd.includes(pattern)) {
                        tasks.push(normalizedTask);
                        console.log('🔍 "Oh and" match found:', normalizedTask);
                        return tasks;
                    }
                }
                
                // If no direct match, process as regular task
                const ohAndTasks = extractTasksFromSegment(afterOhAnd);
                if (ohAndTasks.length > 0) {
                    return ohAndTasks;
                }
            }
            
            // STEP 1.6: Handle standalone action words (like "swim", "run")
            const standaloneActions = ['swim', 'run', 'walk', 'read', 'exercise', 'workout', 'clean', 'cook', 'study', 'hike'];
            for (const action of standaloneActions) {
                if (text === action || text.startsWith(action + ' ') || text.endsWith(' ' + action)) {
                    let normalizedAction = action.charAt(0).toUpperCase() + action.slice(1);
                    if (action === 'run') normalizedAction = 'Go for a run';
                    if (action === 'swim') normalizedAction = 'Swim';
                    if (action === 'hike') normalizedAction = 'Go for a hike';
                    tasks.push(normalizedAction);
                    console.log('🔍 Standalone action found:', normalizedAction);
                    return tasks;
                }
            }
            
            // STEP 1.6.5: Handle concatenated task phrases
            const concatenatedPatterns = [
                /go\s+for\s+a\s+run\s+read\s+a\s+book\s+walk\s+my\s+dog/i,
                /read\s+a\s+book\s+walk\s+my\s+dog\s+clean\s+my\s+room/i,
                /go\s+for\s+a\s+run\s+read\s+a\s+book/i,
                /read\s+a\s+book\s+walk\s+my\s+dog/i
            ];
            
            for (const pattern of concatenatedPatterns) {
                if (pattern.test(text)) {
                    console.log('🔍 Found concatenated pattern:', pattern);
                    
                    // Extract individual tasks from the pattern
                    if (text.includes('go for a run')) tasks.push('Go for a run');
                    if (text.includes('read a book')) tasks.push('Read a book');
                    if (text.includes('walk my dog')) tasks.push('Walk my dog');
                    if (text.includes('clean my room')) tasks.push('Clean my room');
                    
                    if (tasks.length > 0) {
                        console.log('🔍 Extracted concatenated tasks:', tasks);
                        return tasks;
                    }
                }
            }
            
            // STEP 1.7: Handle "swim today" specifically
            if (text.includes('swim today')) {
                tasks.push('Swim');
                console.log('🔍 "Swim today" pattern found: Swim');
                return tasks;
            }
            
                         // STEP 2: Extract using flexible patterns
             const patterns = [
                 // "I want to X", "I wanna X", etc.
                 /(?:i\s+)?(?:want(?:\s+to)?|wanna|would\s+like(?:\s+to)?|need(?:\s+to)?|have\s+to|should|plan\s+to|gonna|let's|will)\s+(.+?)(?:\s+today|$)/i,
                 // Direct action patterns (including common typos and swim)
                 /^(clean|cleand|walk|feed|run|swim|hike|exercise|workout|read|call|play|go|see|watch|do|finish|complete|organize|study|work)\s+(.+?)(?:\s+today|$)/i,
                 // Simple task extraction - any meaningful action
                 /^(.+?)(?:\s+today|$)/i
             ];
            
            for (const pattern of patterns) {
                const match = text.match(pattern);
                if (match) {
                    let taskText = '';
                    if (match[1] && match[2]) {
                        // Pattern with action and object (like "clean my room")
                        taskText = `${match[1]} ${match[2]}`.trim();
                    } else if (match[1]) {
                        // Single capture group
                        taskText = match[1].trim();
                    }
                    
                                         if (taskText && taskText.length > 2) {
                         // Clean up the task text and fix common typos
                         taskText = taskText.replace(/\b(my|the|a|an)\b/g, '').trim();
                         taskText = taskText.replace(/\bcleand\b/g, 'clean'); // Fix typo
                         
                         // Special handling for certain tasks
                         if (taskText.toLowerCase().includes('swim')) {
                             taskText = 'Swim';
                         } else if (taskText.toLowerCase().includes('run') && !taskText.toLowerCase().includes('go for')) {
                             taskText = 'Go for a run';
                         } else if (taskText.toLowerCase().includes('hike')) {
                             taskText = 'Go for a hike';
                         }
                         
                         taskText = capitalizeFirst(taskText);
                         tasks.push(taskText);
                         console.log('🔍 Pattern match found:', taskText);
                         break; // Found a match, no need to try other patterns
                     }
                }
            }
            
            return tasks;
        }
        
        // Debug function - call from console to test task extraction
        window.debugTaskExtraction = function(message) {
            console.log('=== DEBUG TASK EXTRACTION ===');
            const result = extractTasksFromMessage(message);
            console.log('Result:', result);
            return result;
        }
        
        // Test the exact user message
        window.testUserMessage = function() {
            console.log('=== TESTING USER MESSAGE ===');
            const message = "I want to cleand my room and walk my dog. Oh and go for a run";
            console.log('Testing message:', message);
            const result = extractTasksFromMessage(message);
            console.log('Should find 3 tasks:', result);
            console.log('Expected: ["Clean my room", "Walk my dog", "Go for a run"]');
            console.log('Found', result.length, 'tasks');
            return result;
        }
        
        // Test the current 4-task message
        window.testCurrentMessage = function() {
            console.log('=== TESTING CURRENT 4-TASK MESSAGE ===');
            const message = "Okay i want to swim today. Go for a run, walk my dog, and read a book";
            console.log('Testing message:', message);
            const result = extractTasksFromMessage(message);
            console.log('Should find 4 tasks:', result);
            console.log('Expected: ["Swim", "Go for a run", "Walk my dog", "Read a book"]');
            console.log('Found', result.length, 'tasks');
            return result;
        }
        
        // Test the new 4-task message with hike
        window.testHikeMessage = function() {
            console.log('=== TESTING HIKE MESSAGE ===');
            const message = "Okay i want to read a book. Go for a run. Walk my dog and go for a hike";
            console.log('Testing message:', message);
            const result = extractTasksFromMessage(message);
            console.log('Should find 4 tasks:', result);
            console.log('Expected: ["Read a book", "Go for a run", "Walk my dog", "Go for a hike"]');
            console.log('Found', result.length, 'tasks');
            return result;
        }
        
        // Test the continuous 4-task message
        window.testContinuousMessage = function() {
            console.log('=== TESTING CONTINUOUS 4-TASK MESSAGE ===');
            const message = "I want to go for a run read a book walk my dog and clean my room today";
            console.log('Testing message:', message);
            const result = extractTasksFromMessage(message);
            console.log('Should find 4 tasks:', result);
            console.log('Expected: ["Go for a run", "Read a book", "Walk my dog", "Clean my room"]');
            console.log('Found', result.length, 'tasks');
            return result;
        }
        
        // Test the comma-separated 4-task message
        window.testCommaMessage = function() {
            console.log('=== TESTING COMMA-SEPARATED 4-TASK MESSAGE ===');
            const message = "I want to read a book, go for a run, walk my dog, and clean my room";
            console.log('Testing message:', message);
            const result = extractTasksFromMessage(message);
            console.log('Should find 4 tasks:', result);
            console.log('Expected: ["Read a book", "Go for a run", "Walk my dog", "Clean my room"]');
            console.log('Found', result.length, 'tasks');
            return result;
        }
        
        // Test the current 4-task message with eat dinner
        window.testEatDinnerMessage = function() {
            console.log('=== TESTING EAT DINNER 4-TASK MESSAGE ===');
            const message = "I want to read a book, walk my dog, eat dinner, and call my mom";
            console.log('Testing message:', message);
            const result = extractTasksFromMessage(message);
            console.log('Should find 4 tasks:', result);
            console.log('Expected: ["Read a book", "Walk my dog", "Eat dinner", "Call my mom"]');
            console.log('Found', result.length, 'tasks');
            return result;
        }
        
        // Test task completion functionality
        window.testTaskCompletion = function() {
            console.log('=== TESTING TASK COMPLETION ===');
            console.log('Current todos:', todos);
            console.log('Todo count:', todos.length);
            
            if (todos.length > 0) {
                const firstTodo = todos[0];
                console.log('Testing completion for first todo:', firstTodo);
                console.log('Current completed state:', firstTodo.completed);
                
                // Toggle the first todo
                toggleTodo(firstTodo.id);
            } else {
                console.log('No todos available to test');
            }
        }
        
        // Debug checkbox click events
        window.debugCheckboxClick = function() {
            console.log('=== DEBUGGING CHECKBOX CLICKS ===');
            const checkboxes = document.querySelectorAll('.todo-checkbox');
            console.log('Found checkboxes:', checkboxes.length);
            
            checkboxes.forEach((checkbox, index) => {
                console.log(`Checkbox ${index}:`, checkbox);
                console.log(`- Classes:`, checkbox.className);
                console.log(`- Onclick:`, checkbox.onclick);
                console.log(`- Parent:`, checkbox.parentElement);
            });
        }
        
        // Test task sorting functionality
        window.testTaskSorting = function() {
            console.log('=== TESTING TASK SORTING ===');
            const dateKey = selectedDate.toISOString().split('T')[0];
            const todayTodos = todos.filter(todo => todo.date === dateKey);
            
            console.log('Original todos:', todayTodos.map(t => `${t.text} (${t.completed ? 'completed' : 'uncompleted'})`));
            
            const sortedTodos = todayTodos.sort((a, b) => {
                if (a.completed === b.completed) {
                    return new Date(a.createdAt) - new Date(b.createdAt);
                }
                return a.completed ? 1 : -1;
            });
            
            console.log('Sorted todos:', sortedTodos.map(t => `${t.text} (${t.completed ? 'completed' : 'uncompleted'})`));
            
            return sortedTodos;
        }
        
        // Test multiple task scenarios
        window.testTaskExamples = function() {
            console.log('=== TESTING MULTIPLE TASK SCENARIOS ===');
            const examples = [
                "I want to clean my room and walk my dog. Oh and go for a run",
                "I need to read a book, also call my mom and go to the gym",
                "Let's walk the dog and then exercise",
                "I want to cook dinner. Also need to do laundry",
                "Okay i want to swim today. Go for a run, walk my dog, and read a book",
                "I want to go for a run read a book walk my dog and clean my room today",
                "I want to read a book, walk my dog, eat dinner, and call my mom"
            ];
            
            examples.forEach((msg, i) => {
                console.log(`\n--- Example ${i + 1}: "${msg}" ---`);
                const tasks = extractTasksFromMessage(msg);
                console.log('Extracted tasks:', tasks);
                console.log('Task count:', tasks.length);
            });
        }
        
        // Debug the specific 4-task issue
        window.debugFourTasks = function() {
            console.log('=== DEBUGGING 4-TASK ISSUE ===');
            const message = "Okay i want to swim today. Go for a run, walk my dog, and read a book";
            
            console.log('Original message:', message);
            console.log('Lowercase:', message.toLowerCase());
            
            // Test each part separately
            const parts = [
                "Okay i want to swim today",
                "Go for a run",
                "walk my dog", 
                "and read a book"
            ];
            
            parts.forEach((part, i) => {
                console.log(`\n--- Testing part ${i + 1}: "${part}" ---`);
                const tasks = extractTasksFromSegment(part.trim());
                console.log('Extracted from this part:', tasks);
            });
            
            // Test full message
            console.log('\n--- Testing full message ---');
            const fullResult = extractTasksFromMessage(message);
            console.log('Full result:', fullResult);
            console.log('Expected 4 tasks, found:', fullResult.length);
        }
        
        // Debug the hike message specifically
        window.debugHikeMessage = function() {
            console.log('=== DEBUGGING HIKE MESSAGE ===');
            const message = "Okay i want to read a book. Go for a run. Walk my dog and go for a hike";
            
            console.log('Original message:', message);
            console.log('Lowercase:', message.toLowerCase());
            
            // Test each part separately
            const parts = [
                "Okay i want to read a book",
                "Go for a run",
                "Walk my dog and go for a hike"
            ];
            
            parts.forEach((part, i) => {
                console.log(`\n--- Testing part ${i + 1}: "${part}" ---`);
                const tasks = extractTasksFromSegment(part.trim());
                console.log('Extracted from this part:', tasks);
            });
            
            // Test full message
            console.log('\n--- Testing full message ---');
            const fullResult = extractTasksFromMessage(message);
            console.log('Full result:', fullResult);
            console.log('Expected 4 tasks, found:', fullResult.length);
        }
        
        // Reset AI typing state - call from console if AI gets stuck
        window.resetAITyping = function() {
            console.log('=== RESETTING AI TYPING STATE ===');
            console.log('Previous isAITyping:', isAITyping);
            isAITyping = false;
            hideAITyping();
            // Remove any stuck typing indicators
            const allTypingIndicators = document.querySelectorAll('.typing-indicator');
            allTypingIndicators.forEach(indicator => indicator.remove());
            console.log('AI typing state reset. isAITyping now:', isAITyping);
            console.log('✅ AI typing state reset successfully');
        }
        
        // Add a more comprehensive reset function
        window.fullAIReset = function() {
            console.log('=== FULL AI RESET ===');
            isAITyping = false;
            hideAITyping();
            const allTypingIndicators = document.querySelectorAll('.typing-indicator');
            allTypingIndicators.forEach(indicator => indicator.remove());
            // Clear any timeouts that might be running
            for (let i = 1; i < 99999; i++) window.clearTimeout(i);
            console.log('Full AI reset complete!');
            addMessageToChat('ai', "🆕 Complete AI reset done! Everything should work normally now. Try sending a message!");
        }
        
        // Test the specific user message patterns
        window.testUserMessage = function() {
            console.log('=== TESTING USER MESSAGE PATTERNS ===');
            const testMessages = [
                'I also want you to call my mom and walk my dog today',
                'I want to read a book',
                'I also want to read a book',
                'want to read a book',
                'read a book',
                'I wanna go to the gym',
                'walk my dog'
            ];
            
            testMessages.forEach(testMessage => {
                console.log('\n--- Testing:', testMessage, '---');
                const tasks = extractTasksFromMessage(testMessage);
                console.log('Extracted tasks:', tasks);
            });
            
            return testMessages.map(msg => ({
                message: msg, 
                tasks: extractTasksFromMessage(msg)
            }));
        }
        
        // Quick test function for the current issue (console only, no UI popup)
        window.testReadBook = function() {
            console.log('=== TESTING "I want to read a book" ===');
            const message = 'I want to read a book';
            const tasks = extractTasksFromMessage(message);
            console.log('Message:', message);
            console.log('Extracted tasks:', tasks);
            console.log('Should detect: ["Read a book"]');
            
            if (tasks.length > 0) {
                console.log('✅ Task detection WORKING');
                console.log('Note: Use testReadBookWithUI() to also show the popup');
            } else {
                console.log('❌ Task detection FAILED');
            }
            
            return tasks;
        }
        
        // Version that shows UI popup (for manual testing only)
        window.testReadBookWithUI = function() {
            const tasks = window.testReadBook();
            if (tasks.length > 0) {
                showDetectedTasks(tasks);
                console.log('UI popup should now be visible');
            }
            return tasks;
        }
        
        // AGGRESSIVE recovery system - clean up any stuck states
        setInterval(() => {
            const indicators = document.querySelectorAll('.typing-indicator');
            
            // If we have indicators but isAITyping is false, clean them up
            if (!isAITyping && indicators.length > 0) {
                console.log('🧹 Cleanup: Removing orphaned typing indicators');
                indicators.forEach(indicator => indicator.remove());
            }
            
            // Extra safety: If isAITyping has been true for more than 10 seconds, force reset
            // This shouldn't happen with our 2-second guaranteed response, but just in case
            if (isAITyping) {
                if (!window.aiTypingStartTime) {
                    window.aiTypingStartTime = Date.now();
                } else if (Date.now() - window.aiTypingStartTime > 10000) {
                    console.log('🚨 EMERGENCY: isAITyping stuck for >10 seconds, force reset');
                    resetAIState();
                    indicators.forEach(indicator => indicator.remove());
                    addMessageToChat('ai', "Sorry, I got stuck for a moment! I'm ready now. What would you like to work on?");
                }
            } else {
                window.aiTypingStartTime = null;
            }
        }, 5000); // Check every 5 seconds
        
        // Debug function - call from console to test AI response
        window.debugAIResponse = function(message) {
            console.log('=== DEBUG AI RESPONSE ===');
            generateAIResponseWithRetry(message || "Hello").then(response => {
                console.log('AI Response:', response);
            }).catch(error => {
                console.error('AI Error:', error);
            });
        }
        
                 // Quick API health check
        window.checkAPIHealth = function() {
            console.log('=== API HEALTH CHECK ===');
            console.log('API Key:', GEMINI_API_KEY ? 'Configured' : 'Missing');
            console.log('API URL:', GEMINI_API_URL);
            
            // Try a simple request
            generateAIResponse("Hello").then(response => {
                console.log('✅ API Status: HEALTHY');
                console.log('Response:', response);
            }).catch(error => {
                console.log('❌ API Status: FAILED');
                console.error('Error:', error.message);
                if (error.message.includes('429')) {
                    console.log('🔍 Diagnosis: Rate limited - wait 30 seconds');
                } else if (error.message.includes('403')) {
                    console.log('🔍 Diagnosis: API key issue or quota exceeded');
                } else if (error.message.includes('network') || error.message.includes('fetch')) {
                    console.log('🔍 Diagnosis: Network connectivity issue');
                } else {
                    console.log('🔍 Diagnosis: Unknown API error');
                }
            });
        }

        // Firebase debug functions
        window.checkFirebaseStatus = function() {
            console.log('=== FIREBASE STATUS CHECK ===');
            console.log('Firebase Enabled:', isFirebaseEnabled);
            console.log('Online Status:', isOnline);
            console.log('Sync Queue Length:', syncQueue.length);
            console.log('Database Instance:', db ? 'Connected' : 'Not connected');
            
            if (isFirebaseEnabled && db) {
                console.log('Testing Firebase connection...');
                db.collection('todos').limit(1).get()
                    .then(snapshot => {
                        console.log('✅ Firebase Status: CONNECTED');
                        console.log('Sample data size:', snapshot.size);
                    })
                    .catch(error => {
                        console.log('❌ Firebase Status: FAILED');
                        console.error('Error:', error.message);
                    });
            } else if (firebaseConfig.apiKey === "demo-api-key") {
                console.log('🔧 Firebase Status: DEMO MODE (using localStorage)');
                console.log('💡 To enable Firebase: Update firebaseConfig with your real config');
            } else {
                console.log('❌ Firebase Status: NOT INITIALIZED');
            }
        }

        window.forceSyncNow = async function() {
            console.log('=== FORCE SYNC NOW ===');
            if (!isFirebaseEnabled) {
                console.log('❌ Firebase not enabled');
                return;
            }
            
            try {
                await DataLayer.saveTodos(todos);
                console.log('✅ Force sync completed');
                updateSyncStatus();
            } catch (error) {
                console.error('❌ Force sync failed:', error);
            }
        }

                 window.clearLocalData = function() {
             console.log('=== CLEARING LOCAL DATA ===');
             localStorage.removeItem('memaster_todos');
             localStorage.removeItem('memaster_scheduled_tasks');
             console.log('✅ Local storage cleared');
             console.log('🔄 Reload page to see changes');
         }

         // Test the second message issue specifically
         window.testSecondMessage = function() {
             console.log('=== TESTING SECOND MESSAGE ISSUE ===');
             console.log('Initial isAITyping state:', isAITyping);
             
             // Force clean state first
             isAITyping = false;
             hideAITyping();
             
             // Simulate first message
             console.log('Sending first message: "I want to feed my dog and read a book"');
             sendMessageProgrammatically("I want to feed my dog and read a book");
             
             // Wait 4 seconds then send second message
             setTimeout(() => {
                 console.log('📍 ABOUT TO SEND SECOND MESSAGE');
                 console.log('📍 Current isAITyping before second message:', isAITyping);
                 console.log('Sending second message: "I also want to call my mom"');
                 sendMessageProgrammatically("I also want to call my mom");
                 
                 // Check state after second message
                 setTimeout(() => {
                     console.log('📍 isAITyping after second message sent:', isAITyping);
                 }, 100);
             }, 4000);
         }
         
         // Simple test for debugging current issue
         window.testSingleMessage = function() {
             console.log('=== TESTING SINGLE MESSAGE ===');
             console.log('Current isAITyping before test:', isAITyping);
             sendMessageProgrammatically("I want to read and eat burgers today");
         }
         
         // Emergency AI reset function
         window.emergencyReset = function() {
             console.log('🚨 EMERGENCY RESET');
             resetAIState();
             const indicators = document.querySelectorAll('.typing-indicator');
             indicators.forEach(i => i.remove());
             console.log('✅ Emergency reset complete, isAITyping:', isAITyping);
         }
         
         // Immediate test - works instantly
         window.testNow = function() {
             console.log('🧪 IMMEDIATE TEST');
             isAITyping = false; // Force clean state
             hideAITyping();
             
             setTimeout(() => {
                 addMessageToChat('user', 'Test message: I want to read a book');
                 addMessageToChat('ai', '📚 Reading is an excellent goal! What type of book are you in the mood for?');
                 console.log('✅ Test complete - AI should have responded');
             }, 100);
         }
         
         // Monitor state continuously
         window.startStateMonitor = function() {
             console.log('🔍 Starting state monitor...');
             window.stateMonitor = setInterval(() => {
                 console.log('🔍 isAITyping:', isAITyping);
             }, 2000);
         }
         
         window.stopStateMonitor = function() {
             if (window.stateMonitor) {
                 clearInterval(window.stateMonitor);
                 console.log('🔍 State monitor stopped');
             }
         }
         
         // Rapid fire test - send multiple messages quickly
         window.rapidFireTest = function() {
             console.log('🔥 RAPID FIRE TEST - Testing multiple quick messages');
             
             // Start state monitor
             startStateMonitor();
             
             // Send first message
             setTimeout(() => {
                 console.log('🔥 Message 1: "I want to read a book"');
                 sendMessageProgrammatically("I want to read a book");
             }, 500);
             
             // Send second message quickly
             setTimeout(() => {
                 console.log('🔥 Message 2: "I also want to call my mom"');
                 sendMessageProgrammatically("I also want to call my mom");
             }, 3000);
             
             // Send third message
             setTimeout(() => {
                 console.log('🔥 Message 3: "And walk my dog"');
                 sendMessageProgrammatically("And walk my dog");
             }, 6000);
             
             // Stop monitor after test
             setTimeout(() => {
                 stopStateMonitor();
                 console.log('🔥 Rapid fire test complete');
             }, 10000);
         }
         
         // Helper function to send messages programmatically
         function sendMessageProgrammatically(message) {
             const input = document.getElementById('chatInput');
             if (input) {
                 input.value = message;
                 sendMessage();
             }
         }

        function capitalizeFirst(str) {
            return str.charAt(0).toUpperCase() + str.slice(1);
        }

        // Detected Tasks Management
        let currentDetectedTasks = [];

        function showDetectedTasks(tasks) {
            console.log('=== showDetectedTasks called ===');
            console.log('Tasks received:', tasks);
            console.log('Tasks length:', tasks.length);
            console.log('Tasks array:', JSON.stringify(tasks));
            
            currentDetectedTasks = tasks;
            const container = document.getElementById('detectedTasksContainer');
            const tasksList = document.getElementById('detectedTasksList');
            
            console.log('Container:', container);
            console.log('TasksList:', tasksList);
            
            if (!container || !tasksList) {
                console.error('Could not find container or tasksList elements');
                return;
            }
            
            // Clear previous tasks
            tasksList.innerHTML = '';
            console.log('Cleared tasksList, now adding', tasks.length, 'tasks');
            
            // Add each detected task
            console.log('About to add', tasks.length, 'tasks to the list');
            tasks.forEach((task, index) => {
                console.log(`Adding task ${index}:`, task);
                const taskItem = document.createElement('div');
                taskItem.className = 'detected-task-item';
                taskItem.style.cssText = 'background: rgba(255, 255, 255, 0.1) !important; border: 1px solid rgba(255, 255, 255, 0.2) !important; border-radius: 8px !important; padding: 10px 12px !important; margin-bottom: 8px !important; color: #ffffff !important; font-size: 14px !important; display: flex !important; align-items: center !important; gap: 10px !important; visibility: visible !important; opacity: 1 !important; position: relative !important; z-index: 10 !important; min-height: 40px !important;';
                taskItem.innerHTML = `
                    <i class="fas fa-check-circle" style="color: #667eea !important; font-size: 14px !important;"></i>
                    <span style="color: #ffffff !important; font-weight: 500 !important;">${task}</span>
                `;
                tasksList.appendChild(taskItem);
                console.log('Task item added. Element:', taskItem);
                console.log('Task item HTML:', taskItem.outerHTML);
            });
            
            // Double-check the list has items
            console.log('tasksList children count:', tasksList.children.length);
            console.log('tasksList.innerHTML:', tasksList.innerHTML);
            
            console.log('TasksList innerHTML after adding tasks:', tasksList.innerHTML);
            
            // Show the container
            container.style.display = 'block';
            console.log('Container display set to block');
            
            // Force visibility
            container.style.visibility = 'visible';
            container.style.opacity = '1';
            
            // Simple scroll to show the latest content since tasks are now fixed positioned
            setTimeout(() => {
                const chatMessages = document.getElementById('chatMessages');
                if (chatMessages) {
                    // Just scroll to bottom to show the latest message
                    chatMessages.scrollTo({
                        top: chatMessages.scrollHeight,
                        behavior: 'smooth'
                    });
                }
            }, 100);
        }

        async function approveDetectedTasks() {
            console.log('approveDetectedTasks called with tasks:', currentDetectedTasks);
            
            if (currentDetectedTasks.length > 0) {
                console.log('Adding tasks to todos array:', currentDetectedTasks);
                
                // Add tasks to the todo list
                currentDetectedTasks.forEach(task => {
                    const newTask = {
                        id: (Date.now() + Math.random()).toString(),
                        text: task,
                        completed: false,
                        date: selectedDate.toISOString().split('T')[0],
                        createdAt: new Date().toISOString()
                    };
                    todos.push(newTask);
                    console.log('Added task to todos:', newTask);
                });
                
                console.log('Current todos array after adding:', todos);
                
                // Save using DataLayer
                try {
                    await DataLayer.saveTodos(todos);
                    console.log('✅ Detected tasks saved successfully');
                } catch (error) {
                    console.error('❌ Failed to save detected tasks:', error);
                    if (!isOnline && isFirebaseEnabled) {
                        currentDetectedTasks.forEach(task => {
                            DataLayer.queueSync('add', {
                                id: (Date.now() + Math.random()).toString(),
                                text: task,
                                completed: false,
                                date: selectedDate.toISOString().split('T')[0],
                                createdAt: new Date().toISOString()
                            });
                        });
                    }
                }
                
                // Update the display
                renderTodos();
                console.log('Called renderTodos()');
                
                // Store task info for success message BEFORE clearing the array
                const taskCount = currentDetectedTasks.length;
                const firstTask = currentDetectedTasks[0];
                
                // Show success message
                const successMsg = taskCount === 1 
                    ? `Added "${firstTask}" to your tasks!`
                    : `Added ${taskCount} tasks to your planner!`;
                    
                addMessageToChat('ai', `✅ Great! ${successMsg} You can find them in your main todo list. What else would you like to work on today?`);
                
                // Hide the detected tasks container (this clears currentDetectedTasks)
                dismissDetectedTasks();
            } else {
                console.log('No tasks to approve - currentDetectedTasks is empty');
                addMessageToChat('ai', `I didn't detect any specific tasks in your message. Could you be more specific about what you'd like to accomplish? For example: 'I need to clean my room' or 'I want to call my mom'.`);
            }
        }

        function dismissDetectedTasks() {
            const container = document.getElementById('detectedTasksContainer');
            container.style.display = 'none';
            currentDetectedTasks = [];
        }


        // Day Schedule Functions
        function openDaySchedule() {
            // Hide all other views
            document.querySelectorAll('.main-screen, .calendar-view, .stats-view').forEach(v => {
                v.classList.remove('active');
            });
            
            // Show day schedule
            document.getElementById('dayScheduleView').classList.add('active');
            
            // Update header
            const dateStr = selectedDate.toLocaleDateString('en-US', {
                weekday: 'long',
                month: 'long',
                day: 'numeric'
            });
            document.getElementById('dayScheduleDate').textContent = dateStr;
            
            // Render time slots
            renderTimeSlots();
            
            currentView = 'daySchedule';
        }

        function closeDaySchedule() {
            document.getElementById('dayScheduleView').classList.remove('active');
            
            // Return to calendar view
            document.getElementById('calendarView').classList.add('active');
            
            // Update navigation
            document.querySelectorAll('.nav-item').forEach(item => {
                item.classList.remove('active');
            });
            document.querySelector('.nav-item:nth-child(2)').classList.add('active'); // Calendar nav item
            
            currentView = 'calendar';
        }

        function renderTimeSlots() {
            const container = document.getElementById('timeSlotsContainer');
            const dateKey = selectedDate.toISOString().split('T')[0];
            const dayTasks = scheduledTasks[dateKey] || {};
            
            container.innerHTML = '';
            
            // Generate 24 hours with 30-minute intervals
            for (let hour = 0; hour < 24; hour++) {
                for (let minute = 0; minute < 60; minute += 30) {
                    const timeKey = `${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;
                    const displayTime = formatTime12Hour(hour, minute);
                    
                    const timeSlot = document.createElement('div');
                    timeSlot.className = `time-slot ${minute === 0 ? 'hour-marker' : ''}`;
                    
                    const timeLabel = document.createElement('div');
                    timeLabel.className = 'time-label';
                    timeLabel.textContent = minute === 0 ? displayTime : '';
                    
                    const timeContent = document.createElement('div');
                    timeContent.className = 'time-content';
                    
                    // Check if there's a task scheduled for this time
                    const task = dayTasks[timeKey];
                    if (task) {
                        const taskElement = createScheduledTaskElement(task, timeKey, dateKey);
                        timeContent.appendChild(taskElement);
                    } else {
                        timeContent.classList.add('empty');
                        timeContent.innerHTML = '<span>Tap to schedule</span>';
                        timeContent.addEventListener('click', () => {
                            selectedTimeSlot = timeKey;
                            showTimeTaskModal();
                        });
                    }
                    
                    timeSlot.appendChild(timeLabel);
                    timeSlot.appendChild(timeContent);
                    container.appendChild(timeSlot);
                }
            }
        }

        function formatTime12Hour(hour, minute) {
            const period = hour >= 12 ? 'PM' : 'AM';
            const displayHour = hour === 0 ? 12 : hour > 12 ? hour - 12 : hour;
            return `${displayHour}:${minute.toString().padStart(2, '0')} ${period}`;
        }

        function createScheduledTaskElement(task, timeKey, dateKey) {
            const taskDiv = document.createElement('div');
            taskDiv.className = 'scheduled-task';
            
            const title = document.createElement('div');
            title.className = 'scheduled-task-title';
            title.textContent = task.title;
            
            const duration = document.createElement('div');
            duration.className = 'scheduled-task-duration';
            duration.textContent = `${task.duration} minutes`;
            
            const actions = document.createElement('div');
            actions.className = 'scheduled-task-actions';
            
            const completeBtn = document.createElement('button');
            completeBtn.className = 'task-action-btn complete';
            completeBtn.innerHTML = '<i class="fas fa-check"></i> Complete';
            completeBtn.onclick = () => completeScheduledTask(dateKey, timeKey);
            
            const editBtn = document.createElement('button');
            editBtn.className = 'task-action-btn';
            editBtn.innerHTML = '<i class="fas fa-edit"></i> Edit';
            editBtn.onclick = () => editScheduledTask(dateKey, timeKey);
            
            const deleteBtn = document.createElement('button');
            deleteBtn.className = 'task-action-btn delete';
            deleteBtn.innerHTML = '<i class="fas fa-trash"></i> Delete';
            deleteBtn.onclick = () => deleteScheduledTask(dateKey, timeKey);
            
            actions.appendChild(completeBtn);
            actions.appendChild(editBtn);
            actions.appendChild(deleteBtn);
            
            taskDiv.appendChild(title);
            taskDiv.appendChild(duration);
            taskDiv.appendChild(actions);
            
            return taskDiv;
        }

        function showTimeTaskModal() {
            const modal = document.getElementById('timeTaskModal');
            const timeSlotSelect = document.getElementById('timeSlotSelect');
            
            // Populate time slot options
            timeSlotSelect.innerHTML = '';
            for (let hour = 0; hour < 24; hour++) {
                for (let minute = 0; minute < 60; minute += 30) {
                    const timeKey = `${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`;
                    const displayTime = formatTime12Hour(hour, minute);
                    const option = document.createElement('option');
                    option.value = timeKey;
                    option.textContent = displayTime;
                    if (timeKey === selectedTimeSlot) {
                        option.selected = true;
                    }
                    timeSlotSelect.appendChild(option);
                }
            }
            
            modal.classList.add('active');
            setTimeout(() => {
                document.getElementById('timeTaskInput').focus();
            }, 300);
        }

        function closeTimeTaskModal() {
            document.getElementById('timeTaskModal').classList.remove('active');
            document.getElementById('timeTaskInput').value = '';
            selectedTimeSlot = null;
        }

        function scheduleTimeTask() {
            const title = document.getElementById('timeTaskInput').value.trim();
            const timeSlot = document.getElementById('timeSlotSelect').value;
            const duration = parseInt(document.getElementById('durationSelect').value);
            
            if (!title) {
                alert('Please enter a task description');
                return;
            }
            
            const dateKey = selectedDate.toISOString().split('T')[0];
            
            // Initialize date in scheduled tasks if it doesn't exist
            if (!scheduledTasks[dateKey]) {
                scheduledTasks[dateKey] = {};
            }
            
            // Create task object
            const task = {
                title: title,
                duration: duration,
                completed: false,
                createdAt: new Date().toISOString()
            };
            
            // Save task
            scheduledTasks[dateKey][timeSlot] = task;
            localStorage.setItem('memaster_scheduled_tasks', JSON.stringify(scheduledTasks));
            
            // Close modal and refresh view
            closeTimeTaskModal();
            renderTimeSlots();
            
            // Show success message
            showToast(`Task scheduled for ${formatTime12Hour(...timeSlot.split(':').map(Number))}!`);
        }

        function completeScheduledTask(dateKey, timeKey) {
            if (scheduledTasks[dateKey] && scheduledTasks[dateKey][timeKey]) {
                scheduledTasks[dateKey][timeKey].completed = true;
                
                // Also add to regular todos as completed
                const task = scheduledTasks[dateKey][timeKey];
                const todo = {
                    id: Date.now().toString(),
                    text: task.title,
                    completed: true,
                    date: dateKey,
                    createdAt: new Date().toISOString()
                };
                todos.push(todo);
                
                localStorage.setItem('memaster_scheduled_tasks', JSON.stringify(scheduledTasks));
                localStorage.setItem('memaster_todos', JSON.stringify(todos));
                
                renderTimeSlots();
                showToast('Task completed! 🎉');
            }
        }

        function editScheduledTask(dateKey, timeKey) {
            if (scheduledTasks[dateKey] && scheduledTasks[dateKey][timeKey]) {
                const task = scheduledTasks[dateKey][timeKey];
                
                // Pre-fill the modal with existing task data
                document.getElementById('timeTaskInput').value = task.title;
                document.getElementById('durationSelect').value = task.duration.toString();
                selectedTimeSlot = timeKey;
                
                showTimeTaskModal();
            }
        }

        function deleteScheduledTask(dateKey, timeKey) {
            if (confirm('Are you sure you want to delete this scheduled task?')) {
                if (scheduledTasks[dateKey] && scheduledTasks[dateKey][timeKey]) {
                    delete scheduledTasks[dateKey][timeKey];
                    localStorage.setItem('memaster_scheduled_tasks', JSON.stringify(scheduledTasks));
                    renderTimeSlots();
                    showToast('Task deleted');
                }
            }
        }



        // Event listeners
        document.getElementById('taskInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                addTask();
            }
        });

        document.getElementById('chatInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                sendMessage();
            }
        });

        // Bottom chat input event listeners
        document.getElementById('bottomChatInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                handleBottomChatInput();
            }
        });

        document.getElementById('bottomChatInput').addEventListener('focus', function() {
            if (!isChatExpanded) {
                openChatModal();
            }
        });

        // Time task input event listener
        document.getElementById('timeTaskInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                scheduleTimeTask();
            }
        });

        // Close swipes when clicking outside todo items
        document.addEventListener('click', function(e) {
            if (!e.target.closest('.todo-item') && !e.target.closest('.todo-delete-area')) {
                closeAllSwipes();
            }
        });

        // Close swipes when navigating
        document.querySelectorAll('.nav-item').forEach(item => {
            item.addEventListener('click', closeAllSwipes);
        });

        // Close swipes when scrolling
        let scrollTimeout;
        document.addEventListener('scroll', function() {
            clearTimeout(scrollTimeout);
            scrollTimeout = setTimeout(closeAllSwipes, 100);
        }, { passive: true });

        // Force input text visibility for mobile browsers
        function forceInputVisibility() {
            // Fix for chat inputs with original styling
            const inputs = document.querySelectorAll('input[type="text"], textarea, select');
            inputs.forEach(input => {
                input.style.setProperty('color', 'white', 'important');
                input.style.setProperty('-webkit-text-fill-color', 'white', 'important');
                input.style.setProperty('-webkit-opacity', '1', 'important');
                input.style.setProperty('opacity', '1', 'important');
                input.style.setProperty('visibility', 'visible', 'important');
                input.style.setProperty('display', input.classList.contains('chat-input') ? 'block' : 'flex', 'important');
                
                // Add event listeners to maintain color while typing
                input.addEventListener('input', function() {
                    this.style.setProperty('color', 'white', 'important');
                    this.style.setProperty('-webkit-text-fill-color', 'white', 'important');
                });
                
                input.addEventListener('focus', function() {
                    this.style.setProperty('color', 'white', 'important');
                    this.style.setProperty('-webkit-text-fill-color', 'white', 'important');
                });
            });

            // Extra handling for specific inputs
            const chatInput = document.getElementById('chatInput');
            const bottomChatInput = document.getElementById('bottomChatInput');
            
            if (chatInput) {
                chatInput.style.setProperty('color', 'white', 'important');
                chatInput.style.setProperty('-webkit-text-fill-color', 'white', 'important');
            }
            
            if (bottomChatInput) {
                bottomChatInput.style.setProperty('color', 'white', 'important');
                bottomChatInput.style.setProperty('-webkit-text-fill-color', 'white', 'important');
            }
        }

        // Initialize the app
        document.addEventListener('DOMContentLoaded', function() {
            // Log available debug functions
            console.log('🤖 MeMaster Debug Functions:');
            console.log('=== AI Functions ===');
            console.log('- resetAITyping() - Reset if AI gets stuck');
            console.log('- fullAIReset() - Complete AI system reset');
            console.log('- checkAPIHealth() - Test if Gemini API is working');
            console.log('- testReadBook() - Test "I want to read a book" detection (console only)');
            console.log('- testReadBookWithUI() - Same as above but shows UI popup');
            console.log('- testUserMessage() - Test multiple message patterns');
            console.log('- debugTaskExtraction("message") - Test task detection');
            console.log('- debugAIResponse("message") - Test AI responses');
            console.log('=== Firebase Functions ===');
            console.log('- checkFirebaseStatus() - Check Firebase connection');
            console.log('- forceSyncNow() - Force sync with Firebase');
            console.log('- clearLocalData() - Clear localStorage (testing only)');
            console.log('=== Issue Testing ===');
            console.log('- testNow() - IMMEDIATE test (works instantly)');
            console.log('- testSingleMessage() - Test a single message (debug current issue)');  
            console.log('- testSecondMessage() - Test the "second message not responding" issue');
            console.log('- rapidFireTest() - Test multiple messages quickly (with monitoring)');
            console.log('- startStateMonitor() - Monitor isAITyping state continuously');
            console.log('- stopStateMonitor() - Stop the state monitor');
            console.log('- emergencyReset() - Force reset if AI gets completely stuck');
            console.log('=== Task Extraction Testing ===');
            console.log('- testCurrentMessage() - Test the current 4-task message');
            console.log('- testHikeMessage() - Test the new 4-task message with hike');
            console.log('- testContinuousMessage() - Test the continuous 4-task message');
            console.log('- testCommaMessage() - Test the comma-separated 4-task message');
            console.log('- testEatDinnerMessage() - Test the current 4-task message with eat dinner');
            console.log('- debugFourTasks() - Debug the 4-task extraction issue');
            console.log('- debugHikeMessage() - Debug the hike message specifically');
            console.log('- testUserMessage() - Test the exact 3-task message from user');
            console.log('- testTaskExamples() - Test multiple task extraction scenarios');
            console.log('- debugTaskExtraction("your message") - Test any message for task extraction');
            console.log('');
            console.log('🔧 Quick Fix: If AI stops responding, try: rapidFireTest() or emergencyReset()');
            console.log('📚 Test Current Issue: testReadBook() (safe - no UI popup)');
            console.log('🏥 Check API Status: checkAPIHealth()');
            console.log('🔥 Check Firebase Status: checkFirebaseStatus()');
            
            // Auto-test removed - was causing unwanted UI popups
            
            // Dismiss any accidentally shown task popups from debugging
            setTimeout(() => {
                const taskContainer = document.getElementById('detectedTasksContainer');
                if (taskContainer && taskContainer.style.display !== 'none') {
                    console.log('🧹 Hiding accidentally shown task popup from debugging');
                    dismissDetectedTasks();
                }
            }, 100);
            
            // Show Firebase setup status
            setTimeout(() => {
                if (firebaseConfig.apiKey === "demo-api-key") {
                    console.log('');
                    console.log('🔥 FIREBASE SETUP REQUIRED');
                    console.log('Your app is currently in demo mode using localStorage.');
                    console.log('To enable offline sync:');
                    console.log('1. Create a Firebase project at https://console.firebase.google.com');
                    console.log('2. Enable Firestore database');
                    console.log('3. Replace firebaseConfig with your real config');
                    console.log('4. Your tasks will sync across devices and work offline!');
                    console.log('');
                } else if (isFirebaseEnabled) {
                    console.log('🔥 Firebase enabled! Your tasks sync across devices.');
                }
            }, 1000);
            
            // Force input visibility
            forceInputVisibility();
            
            // Re-apply visibility fixes more frequently for dynamic content
            setInterval(forceInputVisibility, 1000);
            
            // Extra check when AI modal opens
            document.addEventListener('click', function(e) {
                if (e.target.closest('.ai-chat-modal')) {
                    setTimeout(forceInputVisibility, 100);
                }
            });
            
            // iOS Safari viewport fix for portrait mode
            function fixIOSViewport() {
                const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
                const isPortrait = window.innerHeight > window.innerWidth;
                
                if (isIOS && isPortrait) {
                    const chatContainer = document.querySelector('.chat-input-container');
                    if (chatContainer) {
                        chatContainer.style.setProperty('position', 'fixed', 'important');
                        chatContainer.style.setProperty('bottom', '0', 'important');
                        chatContainer.style.setProperty('z-index', '200', 'important');
                    }
                }
            }
            
            // Run iOS fix on orientation change and resize
            window.addEventListener('orientationchange', () => {
                setTimeout(fixIOSViewport, 500);
            });
            
            window.addEventListener('resize', fixIOSViewport);
            
            // Initial iOS fix
            fixIOSViewport();
            
            // Initialize sync status immediately
            updateSyncStatus();
            
            // Auto-show main app after 2 seconds or on interaction
            setTimeout(() => {
                if (document.getElementById('welcomeScreen').style.display !== 'none') {
                    showMainApp();
                }
            }, 3000);
            
            // Handle URL shortcuts from PWA manifest
            const params = new URLSearchParams(window.location.search);
            if (params.get('action') === 'add-task') {
                setTimeout(() => {
                    showTaskInputModal();
                }, 1000);
            } else if (params.get('action') === 'ai-chat') {
                setTimeout(() => {
                    openAIChat();
                }, 1000);
            }
        });
        
        // PWA Service Worker Registration
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', async () => {
                try {
                    console.log('PWA: Registering service worker...');
                    const registration = await navigator.serviceWorker.register('./sw.js');
                    console.log('PWA: Service worker registered successfully:', registration.scope);
                    
                    // Handle updates
                    registration.addEventListener('updatefound', () => {
                        const newWorker = registration.installing;
                        newWorker.addEventListener('statechange', () => {
                            if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                                // New version available
                                console.log('PWA: New version available');
                                showToast('New version available! Refresh to update.');
                            }
                        });
                    });
                    
                    // Show install prompt for PWA
                    let deferredPrompt;
                    window.addEventListener('beforeinstallprompt', (e) => {
                        console.log('PWA: Install prompt available');
                        e.preventDefault();
                        deferredPrompt = e;
                        
                        // Show custom install button after 10 seconds
                        setTimeout(() => {
                            showInstallPrompt(deferredPrompt);
                        }, 10000);
                    });
                    
                    // Track if app was launched from home screen
                    if (window.matchMedia && window.matchMedia('(display-mode: standalone)').matches) {
                        console.log('PWA: Launched as standalone app');
                        document.body.classList.add('pwa-mode');
                    }
                    
                } catch (error) {
                    console.error('PWA: Service worker registration failed:', error);
                }
            });
        }
        
        // Show PWA install prompt
        function showInstallPrompt(deferredPrompt) {
            if (!deferredPrompt) return;
            
            const installToast = document.createElement('div');
            installToast.style.cssText = `
                position: fixed;
                bottom: 100px;
                left: 20px;
                right: 20px;
                background: rgba(102, 126, 234, 0.95);
                color: white;
                padding: 15px;
                border-radius: 12px;
                backdrop-filter: blur(10px);
                z-index: 10000;
                text-align: center;
                font-size: 14px;
                line-height: 1.4;
                box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            `;
            installToast.innerHTML = `
                <div style="margin-bottom: 10px;">
                    <strong>📱 Install MeMaster</strong><br>
                    Add to your home screen for the best experience!
                </div>
                <button onclick="installPWA()" style="background: white; color: #667eea; border: none; padding: 8px 16px; border-radius: 6px; font-weight: 500; margin-right: 10px; cursor: pointer;">Install</button>
                <button onclick="dismissInstall()" style="background: transparent; color: white; border: 1px solid rgba(255,255,255,0.3); padding: 8px 16px; border-radius: 6px; font-weight: 500; cursor: pointer;">Later</button>
            `;
            
            document.body.appendChild(installToast);
            window.installToastElement = installToast;
            window.deferredPromptGlobal = deferredPrompt;
        }
        
        // Install PWA
        function installPWA() {
            if (window.deferredPromptGlobal) {
                window.deferredPromptGlobal.prompt();
                window.deferredPromptGlobal.userChoice.then((choiceResult) => {
                    if (choiceResult.outcome === 'accepted') {
                        console.log('PWA: User accepted the install prompt');
                        showToast('🎉 MeMaster installed successfully!');
                    } else {
                        console.log('PWA: User dismissed the install prompt');
                    }
                    window.deferredPromptGlobal = null;
                    dismissInstall();
                });
            }
        }
        
        // Dismiss install prompt
        function dismissInstall() {
            if (window.installToastElement) {
                window.installToastElement.remove();
                window.installToastElement = null;
            }
        }
    </script>
</body>
</html>
